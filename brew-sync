#!/bin/bash

# brew-sync: Homebrew package synchronization tool
# Usage: brew-sync [backup|restore|list|update|uninstall|help] [options]

set -e

# Version and update configuration
GITHUB_REPO="kyungw00k/brew-sync"  # Update with actual repo
SCRIPT_PATH="${BASH_SOURCE[0]}"

# Configuration
ICLOUD_PATH="$HOME/Library/Mobile Documents/com~apple~CloudDocs"
BREW_SYNC_CONFIG_DIR="$HOME/.config/brew-sync"
LAST_STORAGE_FILE="$BREW_SYNC_CONFIG_DIR/last_storage"
# Set default backup directory based on platform
BREW_SYNC_LOCAL_DIR="$HOME/.brew-sync"
if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS - use iCloud as default (but allow first-time choice)
    DEFAULT_BACKUP_DIR="$ICLOUD_PATH/brew-backup"
else
    # Other platforms - use local .brew-sync
    DEFAULT_BACKUP_DIR="$BREW_SYNC_LOCAL_DIR"
fi
BREWFILE_NAME="Brewfile"
HOSTNAME=$(hostname -s)
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
CURRENT_HOSTNAME=$(hostname -s)

# Color settings
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Common logging functions
log_info() {
    echo -e "${BLUE}‚Ä¢${NC} $1"
}

log_success() {
    echo -e "${GREEN}‚úì${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}!${NC} $1"
}

log_error() {
    echo -e "${RED}‚úó${NC} $1"
}

log_merge() {
    echo -e "${CYAN}+${NC} $1"
}

log_restore() {
    echo -e "${CYAN}‚Üí${NC} $1"
}

# Function: Detect all available storage locations
detect_all_storages() {
    local -a storages=()
    
    # 1. Check Git repository
    if git rev-parse --git-dir &>/dev/null; then
        local git_path
        git_path="$(git rev-parse --show-toplevel)"
        storages+=("git|$git_path|Git Repository")
    fi
    
    # 2. Check iCloud Drive (macOS only)
    if [[ "$OSTYPE" == "darwin"* ]] && [ -d "$ICLOUD_PATH" ]; then
        storages+=("icloud|$DEFAULT_BACKUP_DIR|iCloud Drive")
    fi
    
    # 2.5. Always add local storage option
    storages+=("local|$BREW_SYNC_LOCAL_DIR|Local storage (.brew-sync)")
    
    # 3. Check Dropbox
    for dropbox_path in "$HOME/Dropbox" "$HOME/Library/CloudStorage/Dropbox-"*; do
        if [ -d "$dropbox_path" ]; then
            storages+=("dropbox|$dropbox_path/brew-backup|Dropbox")
            break
        fi
    done
    
    # 4. Check Google Drive
    for gdrive_path in "$HOME/Google Drive" "$HOME/Library/CloudStorage/GoogleDrive-"*; do
        if [ -d "$gdrive_path" ]; then
            storages+=("google-drive|$gdrive_path/brew-backup|Google Drive")
            break
        fi
    done
    
    # 5. Check OneDrive
    for onedrive_path in "$HOME/OneDrive" "$HOME/Library/CloudStorage/OneDrive-"*; do
        if [ -d "$onedrive_path" ]; then
            storages+=("onedrive|$onedrive_path/brew-backup|OneDrive")
            break
        fi
    done
    
    # Return the array (each element is "method|path|display_name")
    printf '%s\n' "${storages[@]}"
}

# Function: Save last used storage
save_last_storage() {
    local method="$1"
    local path="$2"
    
    # Create config directory if it doesn't exist
    mkdir -p "$BREW_SYNC_CONFIG_DIR"
    
    # Save storage info (quote path to handle spaces)
    echo "method=$method" > "$LAST_STORAGE_FILE"
    echo "path=\"$path\"" >> "$LAST_STORAGE_FILE"
    echo "timestamp=$(date +%s)" >> "$LAST_STORAGE_FILE"
}

# Function: Load last used storage
load_last_storage() {
    if [ -f "$LAST_STORAGE_FILE" ]; then
        local method path timestamp
        eval "$(grep -E '^(method|path|timestamp)=' "$LAST_STORAGE_FILE")"
        
        # Check if the path still exists
        if [ -n "$method" ] && [ -n "$path" ]; then
            case "$method" in
                git)
                    if git -C "$path" rev-parse --git-dir &>/dev/null; then
                        echo "$method|$path"
                        return 0
                    fi
                    ;;
                *)
                    local check_path="$path"
                    if [ "$method" = "icloud" ]; then
                        check_path="$ICLOUD_PATH"
                    fi
                    if [ -d "${check_path%/brew-backup}" ]; then
                        echo "$method|$path"
                        return 0
                    fi
                    ;;
            esac
        fi
    fi
    return 1
}

# Function: First-time setup for storage selection
first_time_setup() {
    echo ""
    log_info "üç∫ Welcome to brew-sync!"
    echo ""
    echo "Choose your backup storage location:"
    echo ""
    
    # Get available storages
    local -a storages
    while IFS= read -r line; do
        storages+=("$line")
    done < <(detect_all_storages)
    
    # Display options with descriptions
    local i=1
    local recommended_index=0
    for storage in "${storages[@]}"; do
        local method="${storage%%|*}"
        local path="${storage#*|}"
        local display_name="${path##*|}"
        path="${path%|*}"
        
        case "$method" in
            icloud)
                echo "  $i) $display_name (recommended for multiple Macs)" >&2
                echo "     üì± Syncs automatically across your Macs" >&2
                echo "     üìÇ $path" >&2
                if [[ "$OSTYPE" == "darwin"* ]]; then
                    recommended_index=$i
                fi
                ;;
            local)
                echo "  $i) $display_name" >&2
                echo "     üíª Stays on this Mac only" >&2
                echo "     üìÇ $path" >&2
                if [[ "$OSTYPE" != "darwin"* ]]; then
                    recommended_index=$i
                fi
                ;;
            git)
                echo "  $i) $display_name" >&2
                echo "     üîÑ Version control and manual sync" >&2
                echo "     üìÇ $path" >&2
                ;;
            *)
                echo "  $i) $display_name" >&2
                echo "     ‚òÅÔ∏è  Cloud storage service" >&2
                echo "     üìÇ $path" >&2
                ;;
        esac
        echo "" >&2
        ((i++))
    done
    
    echo -n "Select storage (1-${#storages[@]}, press Enter for $recommended_index): " >&2
    read -r choice
    
    # Handle empty input
    if [ -z "$choice" ]; then
        choice=$recommended_index
        log_info "Using recommended option: $choice" >&2
    # Validate choice
    elif ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#storages[@]} ]; then
        log_error "Invalid selection. Using recommended option." >&2
        choice=$recommended_index
    fi
    
    # Return selected storage
    local selected="${storages[$((choice-1))]}"
    local method="${selected%%|*}"
    local path="${selected#*|}"
    path="${path%|*}"
    
    # Save selection
    save_last_storage "$method" "$path"
    
    echo ""
    log_success "Storage configured: $method ($path)" >&2
    echo "$method|$path"
}

# Function: Interactive storage selection
select_storage_interactive() {
    local -a storages
    local last_index=0
    while IFS= read -r line; do
        storages+=("$line")
    done < <(detect_all_storages)
    
    
    if [ ${#storages[@]} -eq 0 ]; then
        log_warning "No cloud storage services detected."
        log_info "Using default local backup: $DEFAULT_BACKUP_DIR"
        echo "local|$DEFAULT_BACKUP_DIR"
        return 0
    fi
    
    if [ ${#storages[@]} -eq 1 ]; then
        # Only one storage available, use it
        local storage="${storages[0]}"
        local method="${storage%%|*}"
        local path="${storage#*|}"
        path="${path%|*}"
        echo "$method|$path"
        return 0
    fi
    
    # Multiple storages available, show selection menu
    echo "" >&2
    log_info "Multiple cloud storage services detected:" >&2
    echo "" >&2
    
    local i=1
    for storage in "${storages[@]}"; do
        local method="${storage%%|*}"
        local path="${storage#*|}"
        local display_name="${path##*|}"
        path="${path%|*}"
        echo "  $i) $display_name ($path)" >&2
        ((i++))
    done
    
    # Check for last used storage
    local last_storage
    if last_storage=$(load_last_storage); then
        local last_method="${last_storage%%|*}"
        local last_path="${last_storage#*|}"
        
        # Find the index of last used storage
        local j=1
        for storage in "${storages[@]}"; do
            local storage_method="${storage%%|*}"
            local storage_path="${storage#*|}"
            storage_path="${storage_path%|*}"
            if [ "$storage_method" = "$last_method" ] && [ "$storage_path" = "$last_path" ]; then
                last_index=$j
                break
            fi
            ((j++))
        done
        
        if [ $last_index -gt 0 ]; then
            echo "" >&2
            log_info "Last used: Option $last_index" >&2
        fi
    fi
    
    echo "" >&2
    if [ $last_index -gt 0 ]; then
        echo -n "Select storage location (1-${#storages[@]}, press Enter for $last_index): " >&2
    else
        echo -n "Select storage location (1-${#storages[@]}, press Enter for 1): " >&2
    fi
    read -r choice
    
    # Handle empty input - show default option
    if [ -z "$choice" ]; then
        if [ $last_index -gt 0 ]; then
            choice=$last_index
            log_info "Using last used option: $choice" >&2
        else
            choice=1
            log_info "Using default option: $choice" >&2
        fi
    # Validate choice
    elif ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#storages[@]} ]; then
        log_error "Invalid selection. Using first available option." >&2
        choice=1
    fi
    
    # Return selected storage
    local selected="${storages[$((choice-1))]}"
    local method="${selected%%|*}"
    local path="${selected#*|}"
    path="${path%|*}"
    
    # Save selection for next time
    save_last_storage "$method" "$path"
    
    echo "$method|$path"
}

# Function: Print main usage
usage() {
    echo "brew-sync: Homebrew package synchronization tool"
    echo ""
    echo "Usage:"
    echo "  brew-sync backup [options]    # Backup current packages"
    echo "  brew-sync restore [options]   # Restore packages from backup"
    echo "  brew-sync list                # List available backups"
    echo "  brew-sync update              # Update to latest version"
    echo "  brew-sync uninstall           # Uninstall brew-sync"
    echo "  brew-sync help                # Show this help"
    echo ""
    echo "Backup examples:"
    echo "  brew-sync backup                           # Auto-detect backup location"
    echo "  brew-sync backup --git                     # Backup to Git repository"
    echo "  brew-sync backup --dropbox -p dev          # Backup to Dropbox with dev profile"
    echo ""
    echo "Restore examples:"
    echo "  brew-sync restore                          # Restore from current Mac backup"
    echo "  brew-sync restore --merged                 # Restore from merged backup of all Macs"
    echo "  brew-sync restore --host MacBook-Pro       # Restore from specific Mac backup"
    echo "  brew-sync restore --dry-run                # Preview only"
    echo ""
    echo "For detailed options, add --help to each command:"
    echo "  brew-sync backup --help"
    echo "  brew-sync restore --help"
    echo "  brew-sync update --help"
    echo ""
    echo "Note: Use --select-storage to change your default storage location."
}

# Function: Print backup usage
backup_usage() {
    echo "Usage: brew-sync backup [options]"
    echo ""
    echo "Common options:"
    echo "  -p, --profile NAME   Use profile (e.g., dev, design)"
    echo "  --select-storage     Choose storage location interactively (**saves as default**)"
    echo "  --git                Backup to Git repository (temporary)"
    echo "  --icloud             Backup to iCloud Drive (temporary)"
    echo "  --dropbox            Backup to Dropbox (temporary)"
    echo "  --path PATH          Backup to custom path (temporary)"
    echo ""
    echo "Examples:"
    echo "  brew-sync backup                    # Auto-detect best location"
    echo "  brew-sync backup --git              # Use Git repository once"
    echo "  brew-sync backup --select-storage   # Choose and save as default"
    echo "  brew-sync backup -p dev             # Backup dev profile"
    echo ""
    echo "Note: Only --select-storage changes your default. Other options are temporary."
    echo "For all options: brew-sync backup --help-all"
}

# Function: Print backup usage (full)
backup_usage_full() {
    echo "Usage: brew-sync backup [options]"
    echo ""
    echo "Backup location options:"
    if [[ "$OSTYPE" == "darwin"* ]]; then
        echo "  --icloud             Use iCloud Drive (default on macOS)"
    else
        echo "  --icloud             Use iCloud Drive"
    fi
    echo "  --git                Backup to Git repository"
    echo "  --dropbox            Backup to Dropbox folder"
    echo "  --google-drive       Backup to Google Drive folder"
    echo "  --path PATH          Custom path"
    echo "  --usb VOLUME         Backup to USB drive (e.g., MyUSB)"
    echo ""
    echo "Backup options:"
    echo "  -p, --profile NAME   Specify profile name (e.g., dev, design)"
    echo "  --no-merge          Disable merge functionality"
    echo "  --select-storage    **Interactively choose storage location (saves as new default)**"
    echo "  --auto-detect       Auto-detect optimal backup location (default)"
    echo "  -h, --help          Show this help"
    echo ""
    echo "**IMPORTANT**: Only --select-storage changes your default storage setting."
    echo "              Other location options are temporary for this backup only."
    echo ""
    echo "Examples:"
    echo "  brew-sync backup                           # Auto-detect optimal location"
    echo "  brew-sync backup --git                     # Backup to Git repository"
    echo "  brew-sync backup --dropbox -p dev          # Backup to Dropbox with dev profile"
    echo "  brew-sync backup --path ~/my-backup        # Custom path"
    echo "  brew-sync backup --usb MyUSB               # Backup to USB drive"
}

# Function: Print restore usage
restore_usage() {
    echo "Usage: brew-sync restore [options]"
    echo ""
    echo "What to restore:"
    echo "  (default)            Current Mac's backup"
    echo "  --merged             All Macs combined"
    echo "  --host HOSTNAME      Specific Mac's backup"
    echo "  -p, --profile NAME   Specific profile"
    echo ""
    echo "Where to restore from:"
    echo "  (default)            Last used storage location"
    echo "  --select-storage     Choose location interactively (**saves as default**)"
    echo "  --git, --icloud      Temporary: use specific storage"
    echo "  --dropbox, --path    Temporary: use specific storage"
    echo ""
    echo "Other options:"
    echo "  -d, --dry-run        Preview only (recommended first)"
    echo "  -l, --list           List available backups"
    echo ""
    echo "Examples:"
    echo "  brew-sync restore --dry-run         # Preview your backup"
    echo "  brew-sync restore                   # Restore your backup"
    echo "  brew-sync restore --merged          # Restore from all Macs"
    echo "  brew-sync restore --host MacBook    # Restore from MacBook"
    echo ""
    echo "Note: Only --select-storage changes your default. Other options are temporary."
    echo "For all options: brew-sync restore --help-all"
}

# Function: Print restore usage (full)
restore_usage_full() {
    echo "Usage: brew-sync restore [options]"
    echo ""
    echo "Backup source options:"
    echo "  --icloud               Restore from iCloud Drive"
    echo "  --git                  Restore from Git repository"
    echo "  --dropbox              Restore from Dropbox"
    echo "  --google-drive         Restore from Google Drive"
    echo "  --path PATH            Restore from custom path"
    echo "  --usb VOLUME           Restore from USB drive"
    echo "  --select-storage       **Interactively choose storage location (saves as new default)**"
    echo "  --auto-detect          Auto-detect optimal backup location (default)"
    echo ""
    echo "Restore type options (select one):"
    echo "  --merged               Use merged Brewfile (packages from all Macs)"
    echo "  --host HOSTNAME        Use specific Mac's Brewfile"
    echo "  -p, --profile NAME     Use specific profile"
    echo "  (default: current Mac's Brewfile)"
    echo ""
    echo "Installation options:"
    echo "  -d, --dry-run          Preview only without actual installation"
    echo "  -f, --force            Overwrite existing Brewfile and proceed"
    echo "  --skip-mas             Skip Mac App Store app installation"
    echo "  -v, --verbose          Verbose output"
    echo "  -l, --list             List available backups"
    echo "  -h, --help             Show this help"
    echo ""
    echo "**IMPORTANT**: Only --select-storage changes your default storage setting."
    echo "              Other source options are temporary for this restore only."
    echo ""
    echo "Examples:"
    echo "  brew-sync restore                     # Auto-detect and restore current Mac backup"
    echo "  brew-sync restore --git --merged      # Restore from Git repository merged packages"
    echo "  brew-sync restore --dropbox --host MacBook-Pro  # Restore from specific Mac backup in Dropbox"
    echo "  brew-sync restore --path ~/backup -p dev --merged  # Restore from custom path dev profile merged"
}

# Function: Auto-detect backup location with smart selection
detect_backup_location() {
    local interactive_mode="$1"  # "interactive" or empty for auto-detect
    
    # Check for first-time setup (no config file exists)
    if [ ! -f "$LAST_STORAGE_FILE" ] && [ "$interactive_mode" != "interactive" ]; then
        log_info "First time running brew-sync..."
        local selection
        selection=$(first_time_setup)
        local method="${selection%%|*}"
        local path="${selection#*|}"
        
        BACKUP_DIR="$path"
        BACKUP_METHOD="$method"
        return 0
    fi
    
    # Try to use last used storage if available (but not in interactive mode)
    local last_storage
    if [ "$interactive_mode" != "interactive" ] && last_storage=$(load_last_storage); then
        local method="${last_storage%%|*}"
        local path="${last_storage#*|}"
        
        log_info "Using last saved storage: $method ($path)"
        BACKUP_DIR="$path"
        BACKUP_METHOD="$method"
        return 0
    fi
    
    # Get all available storages
    local -a storages
    while IFS= read -r line; do
        storages+=("$line")
    done < <(detect_all_storages)
    
    if [ ${#storages[@]} -eq 0 ]; then
        # No cloud storage detected, use local default
        log_warning "No cloud storage services detected."
        log_info "Using default local backup: $DEFAULT_BACKUP_DIR"
        BACKUP_DIR="$DEFAULT_BACKUP_DIR"
        BACKUP_METHOD="local"
        return 0
    fi
    
    if [ ${#storages[@]} -eq 1 ] && [ "$interactive_mode" != "interactive" ]; then
        # Only one storage available, use it automatically
        local storage="${storages[0]}"
        local method="${storage%%|*}"
        local path="${storage#*|}"
        path="${path%|*}"
        local display_name="${storage##*|}"
        
        log_info "$display_name detected: $path"
        BACKUP_DIR="$path"
        BACKUP_METHOD="$method"
        
        # Save this choice for future use
        save_last_storage "$method" "$path"
        return 0
    fi
    
    # Multiple storages available or interactive mode requested
    if [ "$interactive_mode" = "interactive" ] || [ ${#storages[@]} -gt 1 ]; then
        local selection
        selection=$(select_storage_interactive)
        local method="${selection%%|*}"
        local path="${selection#*|}"
        
        local display_name=""
        for storage in "${storages[@]}"; do
            local storage_method="${storage%%|*}"
            local storage_path="${storage#*|}"
            storage_path="${storage_path%|*}"
            if [ "$storage_method" = "$method" ] && [ "$storage_path" = "$path" ]; then
                display_name="${storage##*|}"
                break
            fi
        done
        
        log_info "Selected: $display_name ($path)"
        BACKUP_DIR="$path"
        BACKUP_METHOD="$method"
        return 0
    fi
    
    # Fallback to local default
    log_warning "Using default local backup: $DEFAULT_BACKUP_DIR"
    BACKUP_DIR="$DEFAULT_BACKUP_DIR"
    BACKUP_METHOD="local"
}

# Function: Handle Git backup
handle_git_backup() {
    if ! git rev-parse --git-dir &>/dev/null; then
        log_error "Current directory is not a Git repository."
        log_info "To initialize Git repository:"
        log_info "  git init"
        log_info "  git remote add origin <repository-url>"
        exit 1
    fi
    
    local git_root=$(git rev-parse --show-toplevel)
    BACKUP_DIR="$git_root"
    BACKUP_METHOD="git"
    
    log_info "Backing up to Git repository: $git_root"
}

# Function: List available backups
list_backups() {
    log_info "Available backups:"
    echo ""
    
    # Default profile hosts
    if [ -d "$BACKUP_DIR/hosts" ]; then
        echo "üì± Individual Mac backups:"
        for host_dir in "$BACKUP_DIR/hosts"/*; do
            if [ -d "$host_dir" ] && [ -f "$host_dir/Brewfile" ]; then
                hostname=$(basename "$host_dir")
                if [ -f "$host_dir/backup_info.txt" ]; then
                    last_backup=$(grep "Last backup:" "$host_dir/backup_info.txt" | cut -d: -f2- | xargs)
                    package_count=$(grep "Total packages:" "$host_dir/backup_info.txt" | cut -d: -f2 | xargs)
                    echo "  ‚Ä¢ $hostname (packages: $package_count, $last_backup)"
                else
                    echo "  ‚Ä¢ $hostname"
                fi
            fi
        done
        echo ""
    fi
    
    # Merged backup
    if [ -d "$BACKUP_DIR/merged" ]; then
        echo "üîÑ Merged backups:"
        if [ -f "$BACKUP_DIR/merged/Brewfile" ]; then
            if [ -f "$BACKUP_DIR/merged/merge_info.txt" ]; then
                last_merge=$(grep "Last merge:" "$BACKUP_DIR/merged/merge_info.txt" | cut -d: -f2- | xargs)
                mac_count=$(grep "Included Mac count:" "$BACKUP_DIR/merged/merge_info.txt" | cut -d: -f2 | xargs)
                package_count=$(grep "Total packages:" "$BACKUP_DIR/merged/merge_info.txt" | cut -d: -f2 | xargs)
                echo "  ‚Ä¢ Default merged (Macs: ${mac_count}, packages: $package_count, $last_merge)"
            else
                echo "  ‚Ä¢ Default merged"
            fi
        fi
        echo ""
    fi
    
    # Profile-specific backups
    if [ -d "$BACKUP_DIR/profiles" ]; then
        echo "üìÇ Profile backups:"
        for profile_dir in "$BACKUP_DIR/profiles"/*; do
            if [ -d "$profile_dir" ]; then
                profile=$(basename "$profile_dir")
                echo "  Profile: $profile"
                
                # Individual Macs within profile
                for host_dir in "$profile_dir"/*; do
                    if [ -d "$host_dir" ] && [ -f "$host_dir/Brewfile" ]; then
                        hostname=$(basename "$host_dir")
                        if [ -f "$host_dir/backup_info.txt" ]; then
                            package_count=$(grep "Total packages:" "$host_dir/backup_info.txt" | cut -d: -f2 | xargs)
                            echo "    ‚Ä¢ $hostname (packages: $package_count)"
                        else
                            echo "    ‚Ä¢ $hostname"
                        fi
                    fi
                done
                
                # Profile merged backup
                if [ -f "$BACKUP_DIR/merged/Brewfile_$profile" ]; then
                    if [ -f "$BACKUP_DIR/merged/merge_info_$profile.txt" ]; then
                        mac_count=$(grep "Included Mac count:" "$BACKUP_DIR/merged/merge_info_$profile.txt" | cut -d: -f2 | xargs)
                        package_count=$(grep "Total packages:" "$BACKUP_DIR/merged/merge_info_$profile.txt" | cut -d: -f2 | xargs)
                        echo "    üîÑ Merged version (Macs: ${mac_count}, packages: $package_count)"
                    else
                        echo "    üîÑ Merged version"
                    fi
                fi
                echo ""
            fi
        done
    fi
}

# Function: Backup implementation
do_backup() {
    # Default options
    local MERGE_MODE=true
    local PROFILE=""
    local CUSTOM_PATH=""
    local USE_GIT=false
    local AUTO_DETECT=true
    local INTERACTIVE_STORAGE=false

    # Parse backup arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -p|--profile)
                PROFILE="$2"
                shift 2
                ;;
            --no-merge)
                MERGE_MODE=false
                shift
                ;;
            --select-storage)
                INTERACTIVE_STORAGE=true
                AUTO_DETECT=false
                shift
                ;;
            --icloud)
                CUSTOM_PATH="$DEFAULT_BACKUP_DIR"
                AUTO_DETECT=false
                shift
                ;;
            --git)
                USE_GIT=true
                AUTO_DETECT=false
                shift
                ;;
            --dropbox)
                for dropbox_path in "$HOME/Dropbox" "$HOME/Library/CloudStorage/Dropbox-*"; do
                    if [ -d "$dropbox_path" ]; then
                        CUSTOM_PATH="$dropbox_path/brew-backup"
                        break
                    fi
                done
                if [ -z "$CUSTOM_PATH" ]; then
                    log_error "Dropbox folder not found."
                    exit 1
                fi
                AUTO_DETECT=false
                shift
                ;;
            --google-drive)
                for gdrive_path in "$HOME/Google Drive" "$HOME/Library/CloudStorage/GoogleDrive-*"; do
                    if [ -d "$gdrive_path" ]; then
                        CUSTOM_PATH="$gdrive_path/brew-backup"
                        break
                    fi
                done
                if [ -z "$CUSTOM_PATH" ]; then
                    log_error "Google Drive folder not found."
                    exit 1
                fi
                AUTO_DETECT=false
                shift
                ;;
            --path)
                CUSTOM_PATH="$2"
                AUTO_DETECT=false
                shift 2
                ;;
            --usb)
                USB_VOLUME="$2"
                if [ -d "/Volumes/$USB_VOLUME" ]; then
                    CUSTOM_PATH="/Volumes/$USB_VOLUME/brew-backup"
                else
                    log_error "USB drive not found: /Volumes/$USB_VOLUME"
                    exit 1
                fi
                AUTO_DETECT=false
                shift 2
                ;;
            -h|--help)
                backup_usage
                exit 0
                ;;
            --help-all)
                backup_usage_full
                exit 0
                ;;
            *)
                log_error "Unknown backup option: $1"
                backup_usage
                exit 1
                ;;
        esac
    done

    # Determine backup location
    if [ "$USE_GIT" = true ]; then
        handle_git_backup
    elif [ -n "$CUSTOM_PATH" ]; then
        BACKUP_DIR="$CUSTOM_PATH"
        BACKUP_METHOD="custom"
    elif [ "$INTERACTIVE_STORAGE" = true ]; then
        detect_backup_location "interactive"
    elif [ "$AUTO_DETECT" = true ]; then
        detect_backup_location
    else
        BACKUP_DIR="$DEFAULT_BACKUP_DIR"
        BACKUP_METHOD="icloud"
    fi

    # Set directory paths
    if [ -n "$PROFILE" ]; then
        HOST_DIR="$BACKUP_DIR/profiles/$PROFILE/$HOSTNAME"
        PROFILE_SUFFIX="_$PROFILE"
    else
        HOST_DIR="$BACKUP_DIR/hosts/$HOSTNAME"
        PROFILE_SUFFIX=""
    fi

    MERGED_DIR="$BACKUP_DIR/merged"

    # Check Homebrew installation
    if ! command -v brew &> /dev/null; then
        log_error "Homebrew is not installed."
        exit 1
    fi

    # Check and create backup directory
    if [ "$BACKUP_METHOD" = "icloud" ] && [ ! -d "$ICLOUD_PATH" ]; then
        log_error "iCloud Drive is not enabled or path not found."
        log_info "iCloud Drive path: $ICLOUD_PATH"
        log_info "Please use alternative backup methods:"
        log_info "  --git                Use Git repository"
        log_info "  --dropbox            Use Dropbox" 
        log_info "  --google-drive       Use Google Drive"
        log_info "  --path ~/backup      Custom path"
        exit 1
    fi

    # Create backup directories
    mkdir -p "$HOST_DIR"
    if [ "$MERGE_MODE" = true ]; then
        mkdir -p "$MERGED_DIR"
    fi

    log_info "Starting Brewfile backup..."
    if [ -n "$PROFILE" ]; then
        log_info "Profile: $PROFILE"
    fi
    log_info "Host: $HOSTNAME"

    # Generate Brewfile in temporary directory
    TEMP_DIR=$(mktemp -d)
    cd "$TEMP_DIR"

    # Generate Brewfile
    log_info "Generating current package list..."
    if brew bundle dump --force; then
        log_success "Brewfile generation completed"
    else
        log_error "Brewfile generation failed"
        rm -rf "$TEMP_DIR"
        exit 1
    fi

    # Host-specific backup
    CURRENT_BREWFILE="$TEMP_DIR/$BREWFILE_NAME"
    HOST_BREWFILE="$HOST_DIR/$BREWFILE_NAME"

    # Compare with existing file
    local CHANGES_DETECTED=false
    if [ -f "$HOST_BREWFILE" ]; then
        if cmp -s "$CURRENT_BREWFILE" "$HOST_BREWFILE"; then
            log_info "[$HOSTNAME] No changes detected."
            CHANGES_DETECTED=false
        else
            log_info "[$HOSTNAME] Changes detected."
            # Backup existing file with timestamp
            BACKUP_FILE="$HOST_DIR/Brewfile_$TIMESTAMP"
            cp "$HOST_BREWFILE" "$BACKUP_FILE"
            log_info "[$HOSTNAME] Backed up existing Brewfile: Brewfile_$TIMESTAMP"
            CHANGES_DETECTED=true
        fi
    else
        log_info "[$HOSTNAME] First backup."
        CHANGES_DETECTED=true
    fi

    # Copy new Brewfile to host directory
    cp "$CURRENT_BREWFILE" "$HOST_BREWFILE"

    # Create host-specific backup info file
    cat > "$HOST_DIR/backup_info.txt" << EOF
Hostname: $HOSTNAME
Last backup: $(date)
User: $(whoami)
macOS version: $(sw_vers -productVersion)
Homebrew version: $(brew --version | head -n1)
Profile: ${PROFILE:-"default"}
Total packages: $(grep -E '^(brew|cask|mas)' "$HOST_BREWFILE" | wc -l | tr -d ' ')
EOF

    # Package statistics
    BREW_COUNT=$(grep '^brew ' "$HOST_BREWFILE" | wc -l | tr -d ' ')
    CASK_COUNT=$(grep '^cask ' "$HOST_BREWFILE" | wc -l | tr -d ' ')
    MAS_COUNT=$(grep '^mas ' "$HOST_BREWFILE" | wc -l | tr -d ' ')

    log_success "[$HOSTNAME] Backup completed!"
    log_info "Backup location: $HOST_BREWFILE"
    log_info "Package statistics: Homebrew($BREW_COUNT) Cask($CASK_COUNT) MAS($MAS_COUNT)"
    
    # Save the successful backup storage choice for future use
    save_last_storage "$BACKUP_METHOD" "$BACKUP_DIR"

    # Perform merge operation
    if [ "$MERGE_MODE" = true ] && [ "$CHANGES_DETECTED" = true ]; then
        log_merge "Starting multi-Mac environment merge..."
        
        # Collect Brewfiles from all hosts
        ALL_BREWFILES=()
        if [ -n "$PROFILE" ]; then
            SEARCH_DIR="$BACKUP_DIR/profiles/$PROFILE"
        else
            SEARCH_DIR="$BACKUP_DIR/hosts"
        fi
        
        if [ -d "$SEARCH_DIR" ]; then
            while IFS= read -r -d '' brewfile; do
                ALL_BREWFILES+=("$brewfile")
            done < <(find "$SEARCH_DIR" -name "Brewfile" -type f -print0)
        fi
        
        if [ ${#ALL_BREWFILES[@]} -gt 1 ]; then
            log_merge "Found Macs: ${#ALL_BREWFILES[@]}"
            
            # Generate merged Brewfile
            MERGED_BREWFILE="$MERGED_DIR/Brewfile$PROFILE_SUFFIX"
            TEMP_MERGED="$TEMP_DIR/merged_brewfile"
            
            # Collect and sort tap statements
            {
                echo "# Merged Brewfile - $(date)"
                echo "# Included Macs: $(find "$SEARCH_DIR" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | tr '\n' ' ')"
                echo ""
                
                # Collect taps
                for brewfile in "${ALL_BREWFILES[@]}"; do
                    grep '^tap ' "$brewfile" 2>/dev/null || true
                done | sort -u
                
                echo ""
                
                # Collect brews
                for brewfile in "${ALL_BREWFILES[@]}"; do
                    grep '^brew ' "$brewfile" 2>/dev/null || true
                done | sort -u
                
                echo ""
                
                # Collect casks
                for brewfile in "${ALL_BREWFILES[@]}"; do
                    grep '^cask ' "$brewfile" 2>/dev/null || true
                done | sort -u
                
                echo ""
                
                # Collect mas
                for brewfile in "${ALL_BREWFILES[@]}"; do
                    grep '^mas ' "$brewfile" 2>/dev/null || true
                done | sort -u
                
            } > "$TEMP_MERGED"
            
            # Compare with existing merge file
            if [ -f "$MERGED_BREWFILE" ] && cmp -s "$TEMP_MERGED" "$MERGED_BREWFILE"; then
                log_merge "No changes in merged file."
            else
                # Backup existing merge file
                if [ -f "$MERGED_BREWFILE" ]; then
                    cp "$MERGED_BREWFILE" "$MERGED_DIR/Brewfile${PROFILE_SUFFIX}_$TIMESTAMP"
                    log_merge "Backed up existing merge file."
                fi
                
                cp "$TEMP_MERGED" "$MERGED_BREWFILE"
                
                # Merge statistics
                MERGED_BREW=$(grep '^brew ' "$MERGED_BREWFILE" | wc -l | tr -d ' ')
                MERGED_CASK=$(grep '^cask ' "$MERGED_BREWFILE" | wc -l | tr -d ' ')
                MERGED_MAS=$(grep '^mas ' "$MERGED_BREWFILE" | wc -l | tr -d ' ')
                
                log_success "Merge completed! Total packages: Homebrew($MERGED_BREW) Cask($MERGED_CASK) MAS($MERGED_MAS)"
                log_info "Merge file location: $MERGED_BREWFILE"
            fi
            
            # Create merge info file
            cat > "$MERGED_DIR/merge_info$PROFILE_SUFFIX.txt" << EOF
Last merge: $(date)
Profile: ${PROFILE:-"default"}
Included Mac count: ${#ALL_BREWFILES[@]}
Included Macs: $(find "$SEARCH_DIR" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | tr '\n' ' ')
Total packages: $(grep -E '^(brew|cask|mas)' "$MERGED_BREWFILE" | wc -l | tr -d ' ')
EOF
            
        else
            log_merge "Only current Mac found, merge not needed."
        fi
    fi

    # Clean up temporary directory
    rm -rf "$TEMP_DIR"

    # Clean up old backup files (keep 30 per host)
    OLD_BACKUPS=$(ls -1 "$HOST_DIR"/Brewfile_* 2>/dev/null | wc -l | tr -d ' ')
    if [ "$OLD_BACKUPS" -gt 30 ]; then
        log_info "[$HOSTNAME] Cleaning up old backup files..."
        ls -1t "$HOST_DIR"/Brewfile_* | tail -n +31 | xargs rm -f
    fi

    # Clean up old merge files
    if [ "$MERGE_MODE" = true ] && [ -d "$MERGED_DIR" ]; then
        OLD_MERGED=$(ls -1 "$MERGED_DIR"/Brewfile${PROFILE_SUFFIX}_* 2>/dev/null | wc -l | tr -d ' ')
        if [ "$OLD_MERGED" -gt 20 ]; then
            log_merge "Cleaning up old merge backups..."
            ls -1t "$MERGED_DIR"/Brewfile${PROFILE_SUFFIX}_* | tail -n +21 | xargs rm -f
        fi
    fi

    log_success "All operations completed!"

    # Git repository commit and push suggestion
    if [ "$BACKUP_METHOD" = "git" ] && [ "$CHANGES_DETECTED" = true ]; then
        echo ""
        log_info "üîÑ Git backup follow-up actions:"
        log_info "  Commit changes: git add . && git commit -m \"Update Brewfile from $HOSTNAME\""
        log_info "  Push to remote: git push"
        echo ""
        echo -n "Would you like to commit and push to Git now? (y/N): "
        read -r git_response
        if [[ "$git_response" =~ ^[Yy]$ ]]; then
            cd "$BACKUP_DIR"
            git add .
            if git commit -m "Update Brewfile from $HOSTNAME - $(date)"; then
                log_success "Git commit completed"
                if git push 2>/dev/null; then
                    log_success "Git push completed"
                else
                    log_warning "Git push failed. Please push manually: git push"
                fi
            else
                log_info "No changes to commit."
            fi
        fi
    fi

    # Available restore options guide
    echo ""
    log_info "üì± Restore options:"
    case "$BACKUP_METHOD" in
        "git")
            log_info "  On other Mac: git clone <repository-url> && cd <repo> && brew-sync restore"
            ;;
        "icloud"|"dropbox"|"google-drive")
            log_info "  On other Mac with same cloud service synced:"
            ;;
        "local")
            log_info "  Available only on current Mac:"
            ;;
        "custom")
            log_info "  On other Mac with access to same path:"
            ;;
    esac

    if [ "$BACKUP_METHOD" != "git" ]; then
        log_info "  Individual restore: brew-sync restore --host $HOSTNAME"
        if [ -n "$PROFILE" ]; then
            log_info "  Profile restore: brew-sync restore --profile $PROFILE"
            log_info "  Merged restore: brew-sync restore --profile $PROFILE --merged"
        else
            log_info "  Merged restore: brew-sync restore --merged"
        fi
        
        # Additional guidance by backup method
        case "$BACKUP_METHOD" in
            "local")
                log_warning "Local backup is only available on current Mac."
                log_info "For sharing with other Macs, consider using cloud services or Git."
                ;;
        esac
    fi
}

# Function: Restore implementation
do_restore() {
    # Default options
    local DRY_RUN=false
    local FORCE=false
    local SKIP_MAS=false
    local VERBOSE=false
    local USE_MERGED=false
    local TARGET_HOST=""
    local PROFILE=""
    local CUSTOM_PATH=""
    local USE_GIT=false
    local AUTO_DETECT=true
    local INTERACTIVE_STORAGE=false

    # Parse restore arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -f|--force)
                FORCE=true
                shift
                ;;
            --skip-mas)
                SKIP_MAS=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            --merged)
                USE_MERGED=true
                shift
                ;;
            --host)
                TARGET_HOST="$2"
                shift 2
                ;;
            -p|--profile)
                PROFILE="$2"
                shift 2
                ;;
            -l|--list)
                # Auto-detect backup location for listing
                detect_backup_location 2>/dev/null || BACKUP_DIR="$DEFAULT_BACKUP_DIR"
                list_backups
                exit 0
                ;;
            --icloud)
                CUSTOM_PATH="$DEFAULT_BACKUP_DIR"
                AUTO_DETECT=false
                shift
                ;;
            --git)
                USE_GIT=true
                AUTO_DETECT=false
                shift
                ;;
            --dropbox)
                for dropbox_path in "$HOME/Dropbox" "$HOME/Library/CloudStorage/Dropbox-*"; do
                    if [ -d "$dropbox_path" ]; then
                        CUSTOM_PATH="$dropbox_path/brew-backup"
                        break
                    fi
                done
                if [ -z "$CUSTOM_PATH" ]; then
                    log_error "Dropbox folder not found."
                    exit 1
                fi
                AUTO_DETECT=false
                shift
                ;;
            --google-drive)
                for gdrive_path in "$HOME/Google Drive" "$HOME/Library/CloudStorage/GoogleDrive-*"; do
                    if [ -d "$gdrive_path" ]; then
                        CUSTOM_PATH="$gdrive_path/brew-backup"
                        break
                    fi
                done
                if [ -z "$CUSTOM_PATH" ]; then
                    log_error "Google Drive folder not found."
                    exit 1
                fi
                AUTO_DETECT=false
                shift
                ;;
            --path)
                CUSTOM_PATH="$2"
                AUTO_DETECT=false
                shift 2
                ;;
            --usb)
                USB_VOLUME="$2"
                if [ -d "/Volumes/$USB_VOLUME" ]; then
                    CUSTOM_PATH="/Volumes/$USB_VOLUME/brew-backup"
                else
                    log_error "USB drive not found: /Volumes/$USB_VOLUME"
                    exit 1
                fi
                AUTO_DETECT=false
                shift 2
                ;;
            --select-storage)
                INTERACTIVE_STORAGE=true
                AUTO_DETECT=false
                shift
                ;;
            -h|--help)
                restore_usage
                exit 0
                ;;
            --help-all)
                restore_usage_full
                exit 0
                ;;
            *)
                log_error "Unknown restore option: $1"
                restore_usage
                exit 1
                ;;
        esac
    done

    # Determine backup location
    if [ "$USE_GIT" = true ]; then
        handle_git_backup
    elif [ -n "$CUSTOM_PATH" ]; then
        BACKUP_DIR="$CUSTOM_PATH"
        BACKUP_METHOD="custom"
    elif [ "$INTERACTIVE_STORAGE" = true ]; then
        detect_backup_location "interactive"
    elif [ "$AUTO_DETECT" = true ]; then
        detect_backup_location
    else
        BACKUP_DIR="$DEFAULT_BACKUP_DIR"
        BACKUP_METHOD="icloud"
    fi

    # Determine Brewfile path
    local BACKUP_BREWFILE=""
    local SOURCE_DESC=""
    
    if [ "$USE_MERGED" = true ]; then
        if [ -n "$PROFILE" ]; then
            BACKUP_BREWFILE="$BACKUP_DIR/merged/Brewfile_$PROFILE"
            SOURCE_DESC="Profile '$PROFILE' merged backup"
        else
            BACKUP_BREWFILE="$BACKUP_DIR/merged/Brewfile"
            SOURCE_DESC="All Macs merged backup"
        fi
    elif [ -n "$TARGET_HOST" ]; then
        if [ -n "$PROFILE" ]; then
            BACKUP_BREWFILE="$BACKUP_DIR/profiles/$PROFILE/$TARGET_HOST/Brewfile"
            SOURCE_DESC="$TARGET_HOST (profile: $PROFILE)"
        else
            BACKUP_BREWFILE="$BACKUP_DIR/hosts/$TARGET_HOST/Brewfile"
            SOURCE_DESC="$TARGET_HOST Mac individual backup"
        fi
    elif [ -n "$PROFILE" ]; then
        BACKUP_BREWFILE="$BACKUP_DIR/profiles/$PROFILE/$CURRENT_HOSTNAME/Brewfile"
        SOURCE_DESC="Current Mac's '$PROFILE' profile backup"
    else
        BACKUP_BREWFILE="$BACKUP_DIR/hosts/$CURRENT_HOSTNAME/Brewfile"
        SOURCE_DESC="Current Mac individual backup"
    fi

    # Check Brewfile existence
    if [ ! -f "$BACKUP_BREWFILE" ]; then
        log_error "Backup Brewfile not found: $BACKUP_BREWFILE"
        echo ""
        log_info "To check available backups: brew-sync list"
        echo ""
        log_info "Other options:"
        if [ "$USE_MERGED" = true ]; then
            log_info "  Use individual Mac backup: brew-sync restore --host HOSTNAME"
        else
            log_info "  Use merged backup: brew-sync restore --merged"
        fi
        if [ -z "$PROFILE" ]; then
            log_info "  Specify profile: brew-sync restore --profile PROFILE_NAME"
        fi
        exit 1
    fi

    # Check Homebrew installation
    if ! command -v brew &> /dev/null; then
        log_warning "Homebrew is not installed. Installing..."
        if [ "$DRY_RUN" = false ]; then
            /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
            log_success "Homebrew installation completed"
        else
            log_info "[DRY-RUN] Installing Homebrew"
        fi
    fi

    # Analyze Brewfile contents
    BREW_COUNT=$(grep '^brew ' "$BACKUP_BREWFILE" | wc -l | tr -d ' ')
    CASK_COUNT=$(grep '^cask ' "$BACKUP_BREWFILE" | wc -l | tr -d ' ')
    MAS_COUNT=$(grep '^mas ' "$BACKUP_BREWFILE" | wc -l | tr -d ' ')

    if [ "$DRY_RUN" = true ]; then
        log_info "=== DRY RUN mode - No actual installation will be performed ==="
        echo
        if [ "$USE_MERGED" = true ]; then
            log_info "  Actual installation: brew-sync restore --merged"
        elif [ -n "$TARGET_HOST" ]; then
            log_info "  Actual installation: brew-sync restore --host $TARGET_HOST"
        elif [ -n "$PROFILE" ]; then
            log_info "  Actual installation: brew-sync restore --profile $PROFILE"
        else
            log_info "  Actual installation: brew-sync restore"
        fi
    fi

    log_restore "Restore source: $SOURCE_DESC"
    log_info "Brewfile path: $BACKUP_BREWFILE"

    # Output backup information
    BACKUP_INFO_FILE=$(dirname "$BACKUP_BREWFILE")/backup_info.txt
    MERGE_INFO_FILE=""

    if [ "$USE_MERGED" = true ]; then
        if [ -n "$PROFILE" ]; then
            MERGE_INFO_FILE="$BACKUP_DIR/merged/merge_info_$PROFILE.txt"
        else
            MERGE_INFO_FILE="$BACKUP_DIR/merged/merge_info.txt"
        fi
    fi

    if [ -f "$MERGE_INFO_FILE" ]; then
        log_info "Merged backup information:"
        cat "$MERGE_INFO_FILE" | sed 's/^/  /'
        echo
    elif [ -f "$BACKUP_INFO_FILE" ]; then
        log_info "Backup information:"
        cat "$BACKUP_INFO_FILE" | sed 's/^/  /'
        echo
    fi

    log_info "Package information to restore:"
    log_info "  - Homebrew packages: $BREW_COUNT"
    log_info "  - Cask apps: $CASK_COUNT"
    log_info "  - Mac App Store apps: $MAS_COUNT"
    echo

    # Create temporary directory for Brewfile
    TEMP_BREWFILE_DIR=$(mktemp -d)
    TEMP_BREWFILE="$TEMP_BREWFILE_DIR/Brewfile"
    
    if [ "$DRY_RUN" = false ]; then
        cp "$BACKUP_BREWFILE" "$TEMP_BREWFILE"
        log_success "Copied Brewfile to temporary directory"
    else
        log_info "[DRY-RUN] Copying Brewfile to temporary directory"
    fi

    # Check Mac App Store CLI tool (mas if needed)
    if [ "$MAS_COUNT" -gt 0 ] && [ "$SKIP_MAS" = false ]; then
        if ! command -v mas &> /dev/null; then
            log_info "Mac App Store CLI tool (mas) is required. Installing..."
            if [ "$DRY_RUN" = false ]; then
                brew install mas
            else
                log_info "[DRY-RUN] Installing mas"
            fi
        fi
    fi

    # Configure bundle command
    BUNDLE_ARGS=""
    if [ "$VERBOSE" = true ]; then
        BUNDLE_ARGS="$BUNDLE_ARGS --verbose"
    fi

    if [ "$SKIP_MAS" = true ]; then
        BUNDLE_ARGS="$BUNDLE_ARGS --no-mas"
        log_info "Skipping Mac App Store app installation"
    fi

    # Start package installation
    log_restore "Starting package installation..."

    if [ "$DRY_RUN" = true ]; then
        log_info "[DRY-RUN] Running brew bundle check"
        if brew bundle check --file="$TEMP_BREWFILE" --no-upgrade 2>/dev/null; then
            log_info "[DRY-RUN] All packages are already installed"
        else
            log_info "[DRY-RUN] Packages that need installation:"
            brew bundle check --file="$TEMP_BREWFILE" --no-upgrade 2>&1 | grep -E "^(brew|cask|mas)" | head -10
            TOTAL_MISSING=$(brew bundle check --file="$TEMP_BREWFILE" --no-upgrade 2>&1 | grep -E "^(brew|cask|mas)" | wc -l | tr -d ' ')
            if [ "$TOTAL_MISSING" -gt 10 ]; then
                log_info "[DRY-RUN] ... and $((TOTAL_MISSING - 10)) more"
            fi
            log_info "[DRY-RUN] Following command will be executed:"
            log_info "[DRY-RUN] brew bundle --file=\"$TEMP_BREWFILE\" $BUNDLE_ARGS"
        fi
    else
        # Perform actual installation
        log_info "Running brew bundle..."
        
        if brew bundle --file="$TEMP_BREWFILE" $BUNDLE_ARGS; then
            log_success "All packages installed successfully!"
        else
            log_warning "Some package installations may have failed."
            log_info "Check the output above for details."
            log_info "Retry failed packages: brew bundle --file=\"$TEMP_BREWFILE\" --verbose"
        fi
    fi

    # Post-installation cleanup
    if [ "$DRY_RUN" = false ]; then
        log_info "Performing post-installation cleanup..."
        
        # Homebrew cleanup
        if [ "$VERBOSE" = true ]; then
            brew cleanup --prune=all
        else
            brew cleanup --prune=all &>/dev/null || true
        fi
        
        # Dependency check
        if ! brew doctor &>/dev/null; then
            log_warning "brew doctor warnings detected."
            log_info "To check: brew doctor"
        fi
        
        # Final statistics
        INSTALLED_BREW=$(brew list --formula | wc -l | tr -d ' ')
        INSTALLED_CASK=$(brew list --cask | wc -l | tr -d ' ')
        
        log_success "All operations completed!"
        log_info "Installed environment:"
        log_info "  - Installed packages: Homebrew($INSTALLED_BREW) Cask($INSTALLED_CASK)"
        log_info "  - Check sync: brew bundle check --file=\"$TEMP_BREWFILE\""
        log_info "  - Full list: brew list"
        
        # Additional restore options guidance
        if [ "$USE_MERGED" = false ]; then
            echo ""
            log_info "üí° Other restore options:"
            log_info "  All Mac packages: brew-sync restore --merged"
            if [ -n "$PROFILE" ]; then
                log_info "  Profile merged: brew-sync restore --profile $PROFILE --merged"
            fi
        fi
    else
        log_info "[DRY-RUN] For actual installation, run again without -d option"
        echo ""
        log_info "üí° Recommended commands:"
        if [ "$USE_MERGED" = true ]; then
            log_info "  Actual installation: brew-sync restore --merged"
        elif [ -n "$TARGET_HOST" ]; then
            log_info "  Actual installation: brew-sync restore --host $TARGET_HOST"
        elif [ -n "$PROFILE" ]; then
            log_info "  Actual installation: brew-sync restore --profile $PROFILE"
        else
            log_info "  Actual installation: brew-sync restore"
        fi
    fi
    
    # Cleanup temporary directory
    if [ -n "$TEMP_BREWFILE_DIR" ] && [ -d "$TEMP_BREWFILE_DIR" ]; then
        rm -rf "$TEMP_BREWFILE_DIR"
        log_info "Cleaned up temporary files"
    fi
}

# Function: Print update usage
update_usage() {
    echo "Usage: brew-sync update [options]"
    echo ""
    echo "Options:"
    echo "  --check              Check for updates without installing"
    echo "  --help, -h           Show this help message"
    echo ""
    echo "Examples:"
    echo "  brew-sync update                # Update to latest version"
    echo "  brew-sync update --check        # Check if update is available"
    echo ""
    echo "The update command compares the current version with the latest"
    echo "version from GitHub and updates if a newer version is available."
}

# Function: Uninstall brew-sync
uninstall_brew_sync() {
    log_info "Uninstalling brew-sync..."
    
    # Determine installation directory
    local install_dir="/usr/local/bin"
    if [[ $(uname -m) == "arm64" ]]; then
        install_dir="/opt/homebrew/bin"
    fi
    
    local script_path="$install_dir/brew-sync"
    
    # Check if the script exists
    if [ ! -f "$script_path" ]; then
        log_error "brew-sync is not installed at $script_path"
        return 1
    fi
    
    # Ask for confirmation
    echo ""
    log_warning "This will remove brew-sync from your system."
    echo -n "Are you sure you want to continue? (y/N): "
    read -r response
    
    case "$response" in
        [yY][eE][sS]|[yY])
            # Remove the script
            if [ -w "$install_dir" ]; then
                rm -f "$script_path"
                log_success "brew-sync has been uninstalled successfully"
            else
                sudo rm -f "$script_path"
                log_success "brew-sync has been uninstalled successfully (with sudo)"
            fi
            
            log_info "Note: Your backup files remain untouched."
            log_info "If you want to remove backup files, manually delete them from:"
            log_info "  - iCloud Drive: ~/Library/Mobile Documents/com~apple~CloudDocs/brew-backup"
            log_info "  - Other locations you may have configured"
            ;;
        *)
            log_info "Uninstall cancelled."
            return 0
            ;;
    esac
}

# Function: Check for updates
check_for_updates() {
    local check_only="$1"
    
    # Handle help option
    if [ "$check_only" = "--help" ] || [ "$check_only" = "-h" ]; then
        update_usage
        exit 0
    fi
    
    log_info "Checking for updates..."
    
    # Get current script hash
    local current_hash
    current_hash=$(md5 "$SCRIPT_PATH" 2>/dev/null | cut -d' ' -f4)
    if [ -z "$current_hash" ]; then
        log_error "Failed to calculate current script hash."
        return 1
    fi
    
    log_info "Current script hash: ${current_hash:0:8}..."
    
    # Download latest version to temporary file
    local temp_script
    temp_script=$(mktemp)
    if ! curl -s "https://raw.githubusercontent.com/$GITHUB_REPO/main/brew-sync" -o "$temp_script"; then
        log_error "Failed to download latest version. Please check your internet connection."
        rm -f "$temp_script"
        return 1
    fi
    
    # Get latest script hash
    local latest_hash
    latest_hash=$(md5 "$temp_script" 2>/dev/null | cut -d' ' -f4)
    if [ -z "$latest_hash" ]; then
        log_error "Failed to calculate latest script hash."
        rm -f "$temp_script"
        return 1
    fi
    
    log_info "Latest script hash: ${latest_hash:0:8}..."
    
    # Compare hashes
    if [ "$current_hash" = "$latest_hash" ]; then
        log_success "You are already using the latest version!"
        rm -f "$temp_script"
        return 0
    fi
    
    if [ "$check_only" = "--check" ]; then
        log_info "A new version is available."
        log_info "Run 'brew-sync update' to update."
        rm -f "$temp_script"
        return 0
    fi
    
    # Perform update
    log_info "New version available!"
    echo -n "Do you want to update? (y/N): "
    read -r response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
        log_info "Update cancelled."
        rm -f "$temp_script"
        return 0
    fi
    
    # Find current script location
    local script_path
    script_path=$(which brew-sync 2>/dev/null || readlink -f "$SCRIPT_PATH" 2>/dev/null || echo "$SCRIPT_PATH")
    if [ ! -f "$script_path" ]; then
        log_error "Could not determine script location. Please reinstall manually."
        rm -f "$temp_script"
        return 1
    fi
    
    log_info "Updating brew-sync at: $script_path"
    
    # Backup current version
    local backup_path="${script_path}.backup.$(date +%Y%m%d_%H%M%S)"
    if ! cp "$script_path" "$backup_path"; then
        log_error "Failed to backup current version."
        rm -f "$temp_script"
        return 1
    fi
    
    # Replace script (may require sudo)
    if cp "$temp_script" "$script_path" 2>/dev/null; then
        log_success "Update completed successfully!"
    elif sudo cp "$temp_script" "$script_path" 2>/dev/null; then
        log_success "Update completed successfully! (required sudo)"
    else
        log_error "Failed to update script. Restoring backup..."
        cp "$backup_path" "$script_path" 2>/dev/null || sudo cp "$backup_path" "$script_path"
        rm -f "$temp_script" "$backup_path"
        return 1
    fi
    
    # Set executable permission and cleanup
    chmod +x "$script_path" 2>/dev/null || sudo chmod +x "$script_path"
    rm -f "$temp_script" "$backup_path"
    
    # Verify update
    local new_hash
    new_hash=$(md5 "$script_path" 2>/dev/null | cut -d' ' -f4)
    log_success "Updated successfully!"
    log_info "Previous: ${current_hash:0:8}... ‚Üí Current: ${new_hash:0:8}..."
}

# Function: Show version
show_version() {
    local script_hash
    script_hash=$(md5 "$SCRIPT_PATH" 2>/dev/null | cut -d' ' -f4)
    local mod_date
    mod_date=$(stat -f %Sm -t "%Y-%m-%d %H:%M" "$SCRIPT_PATH" 2>/dev/null || echo "unknown")
    
    echo "brew-sync"
    echo "Script hash: ${script_hash:0:8}..."
    echo "Modified: $mod_date"
}

# Print usage if no arguments
if [ $# -eq 0 ]; then
    usage
    exit 0
fi

# Determine action based on first argument
case "$1" in
    backup)
        shift
        do_backup "$@"
        ;;
    restore)
        shift
        do_restore "$@"
        ;;
    list)
        # Auto-detect backup location for listing
        detect_backup_location 2>/dev/null || BACKUP_DIR="$DEFAULT_BACKUP_DIR"
        list_backups
        ;;
    update)
        shift
        check_for_updates "$@"
        ;;
    uninstall)
        shift
        uninstall_brew_sync "$@"
        ;;
    version|--version|-v)
        show_version
        exit 0
        ;;
    help|--help|-h)
        usage
        exit 0
        ;;
    *)
        log_error "Unknown command: $1"
        echo ""
        usage
        exit 1
        ;;
esac