#!/bin/bash

# brew-sync: Homebrew package synchronization tool
# Usage: brew-sync [backup|restore|list|update|uninstall|help] [options]

set -e

# Version and update configuration
GITHUB_REPO="kyungw00k/brew-sync"  # Update with actual repo
SCRIPT_PATH="${BASH_SOURCE[0]}"

# Configuration
ICLOUD_PATH="$HOME/Library/Mobile Documents/com~apple~CloudDocs"
BREW_SYNC_CONFIG_DIR="$HOME/.config/brew-sync"
LAST_STORAGE_FILE="$BREW_SYNC_CONFIG_DIR/last_storage"
DEFAULT_PROFILE_FILE="$BREW_SYNC_CONFIG_DIR/default_profile"
# Set default backup directory based on platform
BREW_SYNC_LOCAL_DIR="$HOME/.brew-sync"
if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS - use iCloud as default (but allow first-time choice)
    DEFAULT_BACKUP_DIR="$ICLOUD_PATH/brew-backup"
else
    # Other platforms - use local .brew-sync
    DEFAULT_BACKUP_DIR="$BREW_SYNC_LOCAL_DIR"
fi
BREWFILE_NAME="Brewfile"
HOSTNAME=$(hostname -s)
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
CURRENT_HOSTNAME=$(hostname -s)

# Profile configuration
DEFAULT_PROFILE="default"
PROFILE=""
PROFILES_DIR="profiles"
MIGRATION_DIR=".migration"
MIGRATION_FLAG="migrated"
HOSTS_DIR="hosts"

# Color settings
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Global flags
VERBOSE=false

# Enhanced logging functions with verbose support
log_plain() {
    echo "$1"
}

log_info() {
    echo -e "${BLUE}$1${NC}"
}

log_success() {
    echo -e "${GREEN}$1${NC}"
}

log_warning() {
    echo -e "${YELLOW}$1${NC}"
}

log_error() {
    echo -e "${RED}$1${NC}"
}

log_verbose() {
    if [ "$VERBOSE" = true ]; then
        echo -e "${BLUE}  $1${NC}"
    fi
}

log_verbose_plain() {
    if [ "$VERBOSE" = true ]; then
        echo "$1"
    fi
}

log_debug() {
    if [ "$VERBOSE" = true ]; then
        echo -e "${CYAN}  DEBUG: $1${NC}"
    fi
}

# Backward compatibility aliases
log_merge() {
    log_info "$1"
}

log_restore() {
    log_info "$1"
}

log_status() {
    echo -e "${BLUE}$1${NC}"
}

# Helper: Format profile summary for status command (concise)
format_profile_summary() {
    local profile_name="$1"
    local profile_dir="$2"
    local metadata_file="$profile_dir/metadata.json"
    
    if [ ! -f "$metadata_file" ]; then
        echo "$profile_name    (no metadata)"
        return
    fi
    
    # Extract info from metadata
    local last_backup hostname brew_count cask_count mas_count
    last_backup=$(jq -r '.last_backup // "unknown"' "$metadata_file" 2>/dev/null)
    hostname=$(jq -r '.hostname // "unknown"' "$metadata_file" 2>/dev/null)
    brew_count=$(jq -r '.package_count.brew // 0' "$metadata_file" 2>/dev/null)
    cask_count=$(jq -r '.package_count.cask // 0' "$metadata_file" 2>/dev/null)
    mas_count=$(jq -r '.package_count.mas // 0' "$metadata_file" 2>/dev/null)
    
    # Format date (convert ISO to short format)
    local formatted_date
    if [[ "$last_backup" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2} ]]; then
        formatted_date=$(date -j -f "%Y-%m-%dT%H:%M:%S%z" "$last_backup" "+%b %d %H:%M" 2>/dev/null || echo "$last_backup")
    else
        formatted_date="$last_backup"
    fi
    
    printf "%-12s %12s    brew(%s) cask(%s) mas(%s)\n" "$profile_name" "$formatted_date" "$brew_count" "$cask_count" "$mas_count"
}

# Helper: Format profile details for status command (concise)
format_profile_detail() {
    local profile_name="$1"
    local profile_dir="$2"
    local metadata_file="$profile_dir/metadata.json"
    
    if [ ! -f "$metadata_file" ]; then
        echo "Profile: $profile_name"
        echo "No metadata available"
        return
    fi
    
    # Extract info from metadata
    local last_backup hostname brew_count cask_count mas_count total_count
    last_backup=$(jq -r '.last_backup // "unknown"' "$metadata_file" 2>/dev/null)
    hostname=$(jq -r '.hostname // "unknown"' "$metadata_file" 2>/dev/null)
    brew_count=$(jq -r '.package_count.brew // 0' "$metadata_file" 2>/dev/null)
    cask_count=$(jq -r '.package_count.cask // 0' "$metadata_file" 2>/dev/null)
    mas_count=$(jq -r '.package_count.mas // 0' "$metadata_file" 2>/dev/null)
    total_count=$((brew_count + cask_count + mas_count))
    
    # Format date
    local formatted_date
    if [[ "$last_backup" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2} ]]; then
        formatted_date=$(date -j -f "%Y-%m-%dT%H:%M:%S%z" "$last_backup" "+%b %d %H:%M" 2>/dev/null || echo "$last_backup")
    else
        formatted_date="$last_backup"
    fi
    
    echo "Profile: $profile_name"
    echo "Last backup: $formatted_date ($hostname)"
    echo "Packages: $brew_count brew, $cask_count cask, $mas_count mas ($total_count total)"
}

# History management functions

# Function: Get backup history for a profile
get_backup_history() {
    local profile="$1"
    local backup_dir="$2"
    local profile_dir="$backup_dir/profiles/$profile"
    
    if [ ! -d "$profile_dir" ]; then
        return 1
    fi
    
    # Find all backup files with timestamp pattern
    find "$profile_dir" -name "Brewfile_[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]_[0-9][0-9][0-9][0-9][0-9][0-9]*" -type f | sort -r
}

# Function: Parse backup file info
parse_backup_info() {
    local backup_file="$1"
    local filename=$(basename "$backup_file")
    
    # Extract timestamp from filename (Brewfile_YYYYMMDD_HHMMSS format)
    local timestamp=$(echo "$filename" | sed 's/Brewfile_\([0-9]\{8\}_[0-9]\{6\}\).*/\1/')
    
    if [ -n "$timestamp" ]; then
        # Convert timestamp to readable format
        local date_part="${timestamp%_*}"
        local time_part="${timestamp#*_}"
        local formatted_date="${date_part:0:4}-${date_part:4:2}-${date_part:6:2}"
        local formatted_time="${time_part:0:2}:${time_part:2:2}:${time_part:4:2}"
        
        # Count packages in backup file
        local brew_count=0
        local cask_count=0
        local mas_count=0
        
        if [ -f "$backup_file" ]; then
            if [[ "$backup_file" == *.gz ]]; then
                brew_count=$(zcat "$backup_file" 2>/dev/null | grep -c "^brew " 2>/dev/null)
                cask_count=$(zcat "$backup_file" 2>/dev/null | grep -c "^cask " 2>/dev/null)
                mas_count=$(zcat "$backup_file" 2>/dev/null | grep -c "^mas " 2>/dev/null)
            else
                brew_count=$(grep -c "^brew " "$backup_file" 2>/dev/null)
                cask_count=$(grep -c "^cask " "$backup_file" 2>/dev/null)
                mas_count=$(grep -c "^mas " "$backup_file" 2>/dev/null)
            fi
            
            # Clean and validate counts
            brew_count=$(echo "$brew_count" | tr -d '\n\r' | grep -E '^[0-9]+$' || echo "0")
            cask_count=$(echo "$cask_count" | tr -d '\n\r' | grep -E '^[0-9]+$' || echo "0")
            mas_count=$(echo "$mas_count" | tr -d '\n\r' | grep -E '^[0-9]+$' || echo "0")
        fi
        
        local total_count=$((brew_count + cask_count + mas_count))
        
        echo "$formatted_date $formatted_time|$total_count|$backup_file"
    fi
}

# Function: Format relative time
format_relative_time() {
    local backup_date="$1"
    local now=$(date +%s)
    local backup_timestamp=$(date -j -f "%Y-%m-%d %H:%M:%S" "$backup_date" +%s 2>/dev/null)
    
    if [ -n "$backup_timestamp" ]; then
        local diff=$((now - backup_timestamp))
        local days=$((diff / 86400))
        local hours=$(((diff % 86400) / 3600))
        
        if [ $days -gt 0 ]; then
            echo "${days}d ago"
        elif [ $hours -gt 0 ]; then
            echo "${hours}h ago"
        else
            echo "now"
        fi
    else
        echo "$backup_date"
    fi
}

# JSON parsing functions (bash fallback for jq)

# Function: Parse JSON field value using bash
parse_json_field() {
    local json_file="$1"
    local field_path="$2"
    
    if [ ! -f "$json_file" ]; then
        return 1
    fi
    
    case "$field_path" in
        "hostname"|"profile"|"user"|"last_backup"|"macos_version"|"homebrew_version")
            # Simple string fields: "field": "value"
            grep "\"$field_path\":" "$json_file" | sed 's/.*: *"\([^"]*\)".*/\1/' | head -1
            ;;
        "package_count.brew"|"package_count.cask"|"package_count.mas")
            # Nested numeric fields: "field": number
            local pkg_type="${field_path##*.}"  # Extract part after last dot
            grep "\"$pkg_type\":" "$json_file" | sed 's/.*: *\([0-9]*\).*/\1/' | head -1
            ;;
        *)
            return 1
            ;;
    esac
}

# Function: Get metadata field with jq fallback
get_metadata_field() {
    local json_file="$1"
    local field="$2"
    local default_value="${3:-}"
    
    if command -v jq >/dev/null 2>&1; then
        jq -r ".$field // \"$default_value\"" "$json_file" 2>/dev/null
    else
        local result
        result=$(parse_json_field "$json_file" "$field")
        if [ -n "$result" ]; then
            echo "$result"
        else
            echo "$default_value"
        fi
    fi
}

# Migration functions

# Function: Check if migration is needed from hosts to profiles
check_migration_needed() {
    local backup_dir="$1"
    local migration_flag_file="$backup_dir/$MIGRATION_DIR/$MIGRATION_FLAG"
    local hosts_dir="$backup_dir/$HOSTS_DIR"
    
    # If migration flag exists, no migration needed
    if [ -f "$migration_flag_file" ]; then
        return 1
    fi
    
    # If hosts directory exists, migration is needed
    if [ -d "$hosts_dir" ] && [ -n "$(ls -A "$hosts_dir" 2>/dev/null)" ]; then
        return 0
    fi
    
    # No migration needed
    return 1
}

# Function: Suggest profile name from hostname
suggest_profile_name() {
    local hostname="$1"
    
    # Extract user-defined part before machine type
    if [[ "$hostname" =~ ^([A-Za-z]+)-(MacBook|iMac|Mini) ]]; then
        echo "${BASH_REMATCH[1],,}"  # lowercase
        return
    fi
    
    # Machine type based suggestions
    case "$hostname" in
        *MacBook*|*Macbook*) echo "macbook" ;;
        *iMac*|*imac*)       echo "imac" ;;
        *Mini*|*mini*)       echo "mini" ;;
        *)                   echo "machine" ;;
    esac
}

# Function: Validate profile name
validate_profile_name() {
    local profile_name="$1"
    
    # Check if profile name is empty
    if [ -z "$profile_name" ]; then
        return 1
    fi
    
    # Check for invalid characters (only allow alphanumeric, dash, underscore)
    if [[ ! "$profile_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        return 1
    fi
    
    # Check for reserved names
    case "$profile_name" in
        "hosts"|"merged"|"common"|"."|".."|".migration")
            return 1
            ;;
    esac
    
    # Check length (max 50 characters)
    if [ ${#profile_name} -gt 50 ]; then
        return 1
    fi
    
    return 0
}

# Function: Get available profiles
get_available_profiles() {
    local backup_dir="$1"
    local profiles_dir="$backup_dir/$PROFILES_DIR"
    
    if [ ! -d "$profiles_dir" ]; then
        return 1
    fi
    
    local -a profiles=()
    for profile_dir in "$profiles_dir"/*; do
        if [ -d "$profile_dir" ] && [ -f "$profile_dir/Brewfile" ]; then
            local profile_name
            profile_name=$(basename "$profile_dir")
            profiles+=("$profile_name")
        fi
    done
    
    if [ ${#profiles[@]} -eq 0 ]; then
        return 1
    fi
    
    printf '%s\n' "${profiles[@]}"
    return 0
}

# Function: Get profile path
get_profile_path() {
    local backup_dir="$1"
    local profile="${2:-$DEFAULT_PROFILE}"
    echo "$backup_dir/$PROFILES_DIR/$profile"
}

# Function: Recommend profile based on hostname matching
recommend_profile() {
    local backup_dir="$1"
    local current_hostname="$2"
    local profiles_dir="$backup_dir/$PROFILES_DIR"
    
    # First check if any profile has metadata matching current hostname
    if [ -d "$profiles_dir" ]; then
        for profile_dir in "$profiles_dir"/*; do
            if [ -d "$profile_dir" ] && [ -f "$profile_dir/Brewfile" ]; then
                local profile_name
                profile_name=$(basename "$profile_dir")
                
                # Check metadata for hostname match
                if [ -f "$profile_dir/metadata.json" ]; then
                    local hostname_from_meta
                    hostname_from_meta=$(get_metadata_field "$profile_dir/metadata.json" "hostname" "")
                    if [ -n "$hostname_from_meta" ] && [ "$hostname_from_meta" = "$current_hostname" ]; then
                        echo "$profile_name"
                        return 0
                    fi
                    
                    # Also check created_from_host field (from migration)
                    local created_from_host
                    created_from_host=$(get_metadata_field "$profile_dir/metadata.json" "created_from_host" "")
                    if [ -n "$created_from_host" ] && [ "$created_from_host" = "$current_hostname" ]; then
                        echo "$profile_name"
                        return 0
                    fi
                fi
            fi
        done
    fi
    
    # If no hostname match found, recommend default profile
    echo "$DEFAULT_PROFILE"
    return 0
}

# Function: Interactive profile selection for edit command
select_profile_for_edit() {
    local backup_dir="$1"
    local current_hostname="$2"
    
    # Get available profiles
    local -a available_profiles=()
    if get_available_profiles "$backup_dir" >/dev/null 2>&1; then
        while read -r profile_name; do
            available_profiles+=("$profile_name")
        done < <(get_available_profiles "$backup_dir")
    fi
    
    # If no profiles exist, create default profile
    if [ ${#available_profiles[@]} -eq 0 ]; then
        log_error "No profiles found. You need to create a profile first."
        echo "Run 'brew-sync backup' to create your first profile."
        exit 1
    fi
    
    # Get recommended profile
    local recommended_profile
    recommended_profile=$(recommend_profile "$backup_dir" "$current_hostname")
    
    # If only one profile exists and it's the recommended one, use it
    if [ ${#available_profiles[@]} -eq 1 ] && [ "${available_profiles[0]}" = "$recommended_profile" ]; then
        echo "$recommended_profile"
        return 0
    fi
    
    # Show profile selection dialog
    echo "Select a profile to edit:"
    echo ""
    
    # Show available profiles with recommendation
    local i=1
    for profile_name in "${available_profiles[@]}"; do
        if [ "$profile_name" = "$recommended_profile" ]; then
            echo "  $i) $profile_name (recommended - matches current hostname)"
        else
            echo "  $i) $profile_name"
        fi
        ((i++))
    done
    
    echo ""
    
    # Show which profile is recommended and why
    if [[ " ${available_profiles[*]} " =~ " $recommended_profile " ]]; then
        local rec_index=0
        for j in "${!available_profiles[@]}"; do
            if [ "${available_profiles[j]}" = "$recommended_profile" ]; then
                rec_index=$((j + 1))
                break
            fi
        done
        echo -n "Enter your choice (1-${#available_profiles[@]}) [default: $rec_index]: "
    else
        echo -n "Enter your choice (1-${#available_profiles[@]}): "
    fi
    
    read -r choice
    
    # Handle default selection (recommended profile)
    if [ -z "$choice" ] && [[ " ${available_profiles[*]} " =~ " $recommended_profile " ]]; then
        for j in "${!available_profiles[@]}"; do
            if [ "${available_profiles[j]}" = "$recommended_profile" ]; then
                choice=$((j + 1))
                break
            fi
        done
    fi
    
    # Validate choice
    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#available_profiles[@]} ]; then
        log_error "Invalid choice"
        exit 1
    fi
    
    # Return selected profile
    local selected_index=$((choice - 1))
    echo "${available_profiles[selected_index]}"
    return 0
}

# Function: Backup original host data before migration
backup_original_data() {
    local backup_dir="$1"
    local hosts_dir="$backup_dir/$HOSTS_DIR"
    local migration_backup_dir="$backup_dir/$MIGRATION_DIR/backup"
    
    if [ -d "$hosts_dir" ]; then
        log_info "Backing up original host data..."
        mkdir -p "$migration_backup_dir"
        cp -r "$hosts_dir" "$migration_backup_dir/" 2>/dev/null || {
            log_error "Failed to backup original data"
            return 1
        }
        log_success "Original data backed up to $migration_backup_dir"
    fi
    return 0
}

# Function: Create migration completion flag
create_migration_flag() {
    local backup_dir="$1"
    local migration_flag_file="$backup_dir/$MIGRATION_DIR/$MIGRATION_FLAG"
    
    mkdir -p "$(dirname "$migration_flag_file")"
    echo "Migration completed on $(date)" > "$migration_flag_file"
    log_success "Migration flag created"
}

# Function: Migrate single host to default profile
migrate_single_host() {
    local backup_dir="$1"
    local hosts_dir="$backup_dir/$HOSTS_DIR"
    local profiles_dir="$backup_dir/$PROFILES_DIR"
    local default_profile_dir="$profiles_dir/$DEFAULT_PROFILE"
    
    log_info "Found single host backup, migrating to 'default' profile..."
    
    # Find the single host directory
    local host_dir
    host_dir=$(find "$hosts_dir" -maxdepth 1 -type d ! -path "$hosts_dir" | head -1)
    
    if [ -z "$host_dir" ]; then
        log_error "No host directory found"
        return 1
    fi
    
    local hostname
    hostname=$(basename "$host_dir")
    
    # Create profile directory
    mkdir -p "$default_profile_dir"
    
    # Move Brewfile
    if [ -f "$host_dir/Brewfile" ]; then
        cp "$host_dir/Brewfile" "$default_profile_dir/Brewfile" || {
            log_error "Failed to copy Brewfile"
            return 1
        }
    fi
    
    # Create metadata
    cat > "$default_profile_dir/metadata.json" <<EOF
{
    "profile": "$DEFAULT_PROFILE",
    "created_from_host": "$hostname",
    "migration_date": "$(date -Iseconds)",
    "original_path": "$host_dir"
}
EOF
    
    log_success "Migrated $hostname to 'default' profile"
    return 0
}

# Function: Interactive migration for two hosts
# Helper: Get host statistics for migration UI
get_host_stats() {
    local host_dir="$1"
    local pkg_count=0
    local backup_date="unknown"
    
    if [ -f "$host_dir/Brewfile" ]; then
        pkg_count=$(grep -c "^brew\|^cask\|^mas" "$host_dir/Brewfile" 2>/dev/null || echo "0")
        backup_date=$(stat -f %Sm -t "%Y-%m-%d" "$host_dir/Brewfile" 2>/dev/null || echo "unknown")
    fi
    
    echo "$pkg_count|$backup_date"
}

# Helper: Display migration options for two hosts
display_two_host_migration_menu() {
    local host1_name="$1"
    local host2_name="$2"
    local host1_pkgs="$3"
    local host2_pkgs="$4"
    local host1_date="$5"
    local host2_date="$6"
    
    echo
    log_info "Profile Migration Setup"
    echo
    echo "Found 2 existing backups:"
    printf "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n"
    printf "‚îÇ %-16s ‚îÇ %-8s ‚îÇ %-11s ‚îÇ\n" "Host" "Packages" "Last Backup"
    printf "‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n"
    printf "‚îÇ %-16s ‚îÇ %-8s ‚îÇ %-11s ‚îÇ\n" "$host1_name" "$host1_pkgs pkgs" "$host1_date"
    printf "‚îÇ %-16s ‚îÇ %-8s ‚îÇ %-11s ‚îÇ\n" "$host2_name" "$host2_pkgs pkgs" "$host2_date"
    printf "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n"
    echo
    echo "Choose migration strategy:"
    echo "1) üîÑ Merge into 'default' profile (recommended)"
    echo
    echo "2) üìÅ Keep as separate profiles"
    echo "   Which should be your main 'default' profile?"
    echo "   a) $host1_name ($host1_pkgs packages, $host1_date)"
    echo "   b) $host2_name ($host2_pkgs packages, $host2_date)"
    echo
    echo -n "Choice (1/2a/2b): "
}

# Helper: Merge two hosts into default profile
migrate_merge_hosts() {
    local host1_dir="$1"
    local host2_dir="$2"
    local host1_name="$3"
    local host2_name="$4"
    local profiles_dir="$5"
    
    log_info "Merging both hosts into 'default' profile..."
    mkdir -p "$profiles_dir/$DEFAULT_PROFILE"
    
    # Merge Brewfiles
    {
        echo "# Merged from $host1_name and $host2_name"
        echo "# Migration date: $(date)"
        echo
        [ -f "$host1_dir/Brewfile" ] && cat "$host1_dir/Brewfile"
        echo
        [ -f "$host2_dir/Brewfile" ] && cat "$host2_dir/Brewfile"
    } | sort -u > "$profiles_dir/$DEFAULT_PROFILE/Brewfile"
    
    # Create metadata
    cat > "$profiles_dir/$DEFAULT_PROFILE/metadata.json" <<EOF
{
    "profile": "$DEFAULT_PROFILE",
    "created_from_hosts": ["$host1_name", "$host2_name"],
    "migration_date": "$(date -Iseconds)",
    "migration_type": "merged"
}
EOF
    log_success "Merged both hosts into 'default' profile"
}

# Helper: Create separate profiles with one as default
migrate_separate_hosts() {
    local default_host_dir="$1"
    local other_host_dir="$2"
    local default_host_name="$3"
    local other_host_name="$4"
    local profiles_dir="$5"
    
    log_info "Setting $default_host_name as 'default' profile..."
    mkdir -p "$profiles_dir/$DEFAULT_PROFILE"
    [ -f "$default_host_dir/Brewfile" ] && cp "$default_host_dir/Brewfile" "$profiles_dir/$DEFAULT_PROFILE/Brewfile"
    
    local other_profile_name
    other_profile_name=$(suggest_profile_name "$other_host_name")
    mkdir -p "$profiles_dir/$other_profile_name"
    [ -f "$other_host_dir/Brewfile" ] && cp "$other_host_dir/Brewfile" "$profiles_dir/$other_profile_name/Brewfile"
    
    # Create metadata
    cat > "$profiles_dir/$DEFAULT_PROFILE/metadata.json" <<EOF
{
    "profile": "$DEFAULT_PROFILE",
    "created_from_host": "$default_host_name",
    "migration_date": "$(date -Iseconds)"
}
EOF
    cat > "$profiles_dir/$other_profile_name/metadata.json" <<EOF
{
    "profile": "$other_profile_name",
    "created_from_host": "$other_host_name",
    "migration_date": "$(date -Iseconds)"
}
EOF
    log_success "Created 'default' ($default_host_name) and '$other_profile_name' ($other_host_name) profiles"
}

# Function: Interactive migration for two hosts
migrate_two_hosts() {
    local backup_dir="$1"
    local hosts_dir="$backup_dir/$HOSTS_DIR"
    local profiles_dir="$backup_dir/$PROFILES_DIR"
    
    # Get host directories
    local -a host_dirs=()
    while IFS= read -r -d '' dir; do
        host_dirs+=("$dir")
    done < <(find "$hosts_dir" -maxdepth 1 -type d ! -path "$hosts_dir" -print0)
    
    if [ ${#host_dirs[@]} -ne 2 ]; then
        log_error "Expected 2 hosts, found ${#host_dirs[@]}"
        return 1
    fi
    
    local host1_dir="${host_dirs[0]}"
    local host2_dir="${host_dirs[1]}"
    local host1_name host2_name
    host1_name=$(basename "$host1_dir")
    host2_name=$(basename "$host2_dir")
    
    # Get package counts and dates
    local host1_stats host2_stats
    host1_stats=$(get_host_stats "$host1_dir")
    host2_stats=$(get_host_stats "$host2_dir")
    
    local host1_pkgs host1_date host2_pkgs host2_date
    host1_pkgs=$(echo "$host1_stats" | cut -d'|' -f1)
    host1_date=$(echo "$host1_stats" | cut -d'|' -f2)
    host2_pkgs=$(echo "$host2_stats" | cut -d'|' -f1)
    host2_date=$(echo "$host2_stats" | cut -d'|' -f2)
    
    display_two_host_migration_menu "$host1_name" "$host2_name" "$host1_pkgs" "$host2_pkgs" "$host1_date" "$host2_date"
    
    local choice
    read -r choice
    
    case "$choice" in
        1)
            migrate_merge_hosts "$host1_dir" "$host2_dir" "$host1_name" "$host2_name" "$profiles_dir"
            ;;
        2a|2A)
            migrate_separate_hosts "$host1_dir" "$host2_dir" "$host1_name" "$host2_name" "$profiles_dir"
            ;;
        2b|2B)
            migrate_separate_hosts "$host2_dir" "$host1_dir" "$host2_name" "$host1_name" "$profiles_dir"
            ;;
        *)
            log_error "Invalid choice. Migration cancelled."
            return 1
            ;;
    esac
    
    return 0
}

# Helper: Display multiple hosts migration table
display_multiple_hosts_table() {
    local -a host_dirs=("$@")
    local -a host_names=()
    
    # Extract host names from directories
    for dir in "${host_dirs[@]}"; do
        host_names+=("$(basename "$dir")")
    done
    
    echo
    log_info "Profile Migration Setup"
    echo
    echo "Found ${#host_dirs[@]} existing backups:"
    printf "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n"
    printf "‚îÇ %-16s ‚îÇ %-8s ‚îÇ %-11s ‚îÇ\n" "Host" "Packages" "Last Backup"
    printf "‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n"
    
    for i in "${!host_dirs[@]}"; do
        local host_dir="${host_dirs[$i]}"
        local host_name="${host_names[$i]}"
        local host_stats
        host_stats=$(get_host_stats "$host_dir")
        local pkg_count last_date
        pkg_count=$(echo "$host_stats" | cut -d'|' -f1)
        last_date=$(echo "$host_stats" | cut -d'|' -f2)
        
        printf "‚îÇ %-16s ‚îÇ %-8s ‚îÇ %-11s ‚îÇ\n" "$host_name" "$pkg_count pkgs" "$last_date"
    done
    printf "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n"
}

# Helper: Collect profile names from user
collect_profile_names() {
    local -a host_names=("$@")
    local -a profile_names=()
    
    echo
    echo "Multiple machines detected. Let's organize them:"
    echo
    echo "Profile names (press Enter for suggested names):"
    
    for host_name in "${host_names[@]}"; do
        local suggested_name
        suggested_name=$(suggest_profile_name "$host_name")
        echo -n "$host_name ‚Üí [$suggested_name] "
        read -r custom_name
        if [ -n "$custom_name" ]; then
            profile_names+=("$custom_name")
        else
            profile_names+=("$suggested_name")
        fi
    done
    
    echo
    echo "Continue with these names? (Y/n): "
    read -r confirm
    
    if [[ "$confirm" =~ ^[Nn] ]]; then
        return 1
    fi
    
    printf '%s\n' "${profile_names[@]}"
}

# Helper: Create profiles from multiple hosts
create_multiple_profiles() {
    local profiles_dir="$1"
    shift
    local -a host_dirs=("$@")
    
    # First half are host directories, second half are profile names
    local host_count=$((${#host_dirs[@]} / 2))
    local -a actual_host_dirs=("${host_dirs[@]:0:$host_count}")
    local -a profile_names=("${host_dirs[@]:$host_count}")
    
    for i in "${!actual_host_dirs[@]}"; do
        local host_dir="${actual_host_dirs[$i]}"
        local host_name
        host_name=$(basename "$host_dir")
        local profile_name="${profile_names[$i]}"
        local profile_dir="$profiles_dir/$profile_name"
        
        log_info "Creating '$profile_name' profile from $host_name..."
        mkdir -p "$profile_dir"
        
        if [ -f "$host_dir/Brewfile" ]; then
            cp "$host_dir/Brewfile" "$profile_dir/Brewfile"
        fi
        
        cat > "$profile_dir/metadata.json" <<EOF
{
    "profile": "$profile_name",
    "created_from_host": "$host_name",
    "migration_date": "$(date -Iseconds)"
}
EOF
    done
    
    log_success "Created ${#profile_names[@]} profiles: ${profile_names[*]}"
}

# Function: Interactive migration for multiple hosts (3+)
migrate_multiple_hosts() {
    local backup_dir="$1"
    local hosts_dir="$backup_dir/$HOSTS_DIR"
    local profiles_dir="$backup_dir/$PROFILES_DIR"
    
    # Get host directories
    local -a host_dirs=()
    local -a host_names=()
    while IFS= read -r -d '' dir; do
        host_dirs+=("$dir")
        host_names+=("$(basename "$dir")")
    done < <(find "$hosts_dir" -maxdepth 1 -type d ! -path "$hosts_dir" -print0)
    
    display_multiple_hosts_table "${host_dirs[@]}"
    
    # Collect profile names from user
    local profile_names_output
    profile_names_output=$(collect_profile_names "${host_names[@]}")
    if [ $? -ne 0 ]; then
        log_info "Migration cancelled."
        return 1
    fi
    
    # Convert output to array
    local -a profile_names=()
    while IFS= read -r line; do
        profile_names+=("$line")
    done <<< "$profile_names_output"
    
    # Create profiles (pass both arrays by combining them)
    create_multiple_profiles "$profiles_dir" "${host_dirs[@]}" "${profile_names[@]}"
    
    return 0
}

# Function: Main migration orchestrator
migrate_hosts_to_profiles() {
    local backup_dir="$1"
    local hosts_dir="$backup_dir/$HOSTS_DIR"
    
    if ! check_migration_needed "$backup_dir"; then
        return 0
    fi
    
    log_info "üîÑ Migration from host-based to profile-based structure needed..."
    
    # Backup original data
    if ! backup_original_data "$backup_dir"; then
        log_error "Failed to backup original data. Migration aborted."
        return 1
    fi
    
    # Count hosts
    local host_count
    host_count=$(find "$hosts_dir" -maxdepth 1 -type d ! -path "$hosts_dir" | wc -l | tr -d ' ')
    
    case $host_count in
        0)
            log_warning "No host backups found."
            ;;
        1)
            migrate_single_host "$backup_dir" || return 1
            ;;
        2)
            migrate_two_hosts "$backup_dir" || return 1
            ;;
        *)
            migrate_multiple_hosts "$backup_dir" || return 1
            ;;
    esac
    
    # Create migration completion flag
    create_migration_flag "$backup_dir"
    
    log_success "‚úì Migration completed successfully!"
    echo
    log_info "Your backup structure has been updated to use profiles."
    log_info "Original data is preserved in $backup_dir/$MIGRATION_DIR/backup/"
    
    return 0
}

# Function: Detect all available storage locations
detect_all_storages() {
    local -a storages=()
    
    # 1. Check Git repository
    if git rev-parse --git-dir &>/dev/null; then
        local git_path
        git_path="$(git rev-parse --show-toplevel)"
        storages+=("git|$git_path|Git Repository")
    fi
    
    # 2. Check iCloud Drive (macOS only)
    if [[ "$OSTYPE" == "darwin"* ]] && [ -d "$ICLOUD_PATH" ]; then
        storages+=("icloud|$DEFAULT_BACKUP_DIR|iCloud Drive")
    fi
    
    # 2.5. Always add local storage option
    storages+=("local|$BREW_SYNC_LOCAL_DIR|Local storage (.brew-sync)")
    
    # 3. Check Dropbox
    for dropbox_path in "$HOME/Dropbox" "$HOME/Library/CloudStorage/Dropbox-"*; do
        if [ -d "$dropbox_path" ]; then
            storages+=("dropbox|$dropbox_path/brew-backup|Dropbox")
            break
        fi
    done
    
    # 4. Check Google Drive
    for gdrive_path in "$HOME/Google Drive" "$HOME/Library/CloudStorage/GoogleDrive-"*; do
        if [ -d "$gdrive_path" ]; then
            storages+=("google-drive|$gdrive_path/brew-backup|Google Drive")
            break
        fi
    done
    
    # 5. Check OneDrive
    for onedrive_path in "$HOME/OneDrive" "$HOME/Library/CloudStorage/OneDrive-"*; do
        if [ -d "$onedrive_path" ]; then
            storages+=("onedrive|$onedrive_path/brew-backup|OneDrive")
            break
        fi
    done
    
    # Return the array (each element is "method|path|display_name")
    printf '%s\n' "${storages[@]}"
}

# Function: Save last used storage
save_last_storage() {
    local method="$1"
    local path="$2"
    
    # Create config directory if it doesn't exist
    mkdir -p "$BREW_SYNC_CONFIG_DIR"
    
    # Save storage info (quote path to handle spaces)
    echo "method=$method" > "$LAST_STORAGE_FILE"
    echo "path=\"$path\"" >> "$LAST_STORAGE_FILE"
    echo "timestamp=$(date +%s)" >> "$LAST_STORAGE_FILE"
}

# Function: Load last used storage
load_last_storage() {
    if [ -f "$LAST_STORAGE_FILE" ]; then
        local method path timestamp
        eval "$(grep -E '^(method|path|timestamp)=' "$LAST_STORAGE_FILE")"
        
        # Check if the path still exists
        if [ -n "$method" ] && [ -n "$path" ]; then
            case "$method" in
                git)
                    if git -C "$path" rev-parse --git-dir &>/dev/null; then
                        echo "$method|$path"
                        return 0
                    fi
                    ;;
                *)
                    local check_path="$path"
                    if [ "$method" = "icloud" ]; then
                        check_path="$ICLOUD_PATH"
                    fi
                    if [ -d "${check_path%/brew-backup}" ]; then
                        echo "$method|$path"
                        return 0
                    fi
                    ;;
            esac
        fi
    fi
    return 1
}

# Function: Save default profile
save_default_profile() {
    local profile="$1"
    
    # Create config directory if it doesn't exist
    mkdir -p "$BREW_SYNC_CONFIG_DIR"
    
    # Save default profile
    echo "$profile" > "$DEFAULT_PROFILE_FILE"
}

# Function: Load default profile
load_default_profile() {
    if [ -f "$DEFAULT_PROFILE_FILE" ]; then
        cat "$DEFAULT_PROFILE_FILE"
        return 0
    fi
    return 1
}

# Function: First-time setup for storage selection
first_time_setup() {
    echo ""
    log_info "üç∫ Welcome to brew-sync!"
    echo ""
    echo "Choose your backup storage location:"
    echo ""
    
    # Get available storages
    local -a storages
    while IFS= read -r line; do
        storages+=("$line")
    done < <(detect_all_storages)
    
    # Display options with descriptions
    local i=1
    local recommended_index=0
    for storage in "${storages[@]}"; do
        local method="${storage%%|*}"
        local path="${storage#*|}"
        local display_name="${path##*|}"
        path="${path%|*}"
        
        case "$method" in
            icloud)
                echo "  $i) $display_name (recommended for multiple Macs)" >&2
                echo "     Syncs automatically across your Macs" >&2
                echo "     Path: $path" >&2
                if [[ "$OSTYPE" == "darwin"* ]]; then
                    recommended_index=$i
                fi
                ;;
            local)
                echo "  $i) $display_name" >&2
                echo "     üíª Stays on this Mac only" >&2
                echo "     Path: $path" >&2
                if [[ "$OSTYPE" != "darwin"* ]]; then
                    recommended_index=$i
                fi
                ;;
            git)
                echo "  $i) $display_name" >&2
                echo "     üîÑ Version control and manual sync" >&2
                echo "     Path: $path" >&2
                ;;
            *)
                echo "  $i) $display_name" >&2
                echo "     ‚òÅÔ∏è  Cloud storage service" >&2
                echo "     Path: $path" >&2
                ;;
        esac
        echo "" >&2
        ((i++))
    done
    
    echo -n "Select storage (1-${#storages[@]}, press Enter for $recommended_index): " >&2
    read -r choice
    
    # Handle empty input
    if [ -z "$choice" ]; then
        choice=$recommended_index
        log_info "Using recommended option: $choice" >&2
    # Validate choice
    elif ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#storages[@]} ]; then
        log_error "Invalid selection. Using recommended option." >&2
        choice=$recommended_index
    fi
    
    # Return selected storage
    local selected="${storages[$((choice-1))]}"
    local method="${selected%%|*}"
    local path="${selected#*|}"
    path="${path%|*}"
    
    # Save selection
    save_last_storage "$method" "$path"
    
    echo ""
    log_success "Storage configured: $method ($path)" >&2
    echo "$method|$path"
}

# Function: First-time profile setup
first_time_profile_setup() {
    local backup_dir="$1"
    local profiles_dir="$backup_dir/$PROFILES_DIR"
    
    echo ""
    log_info "üîß Profile Setup"
    echo ""
    
    # Check for existing profiles
    local -a existing_profiles=()
    if [ -d "$profiles_dir" ]; then
        while IFS= read -r line; do
            if [ -n "$line" ]; then
                existing_profiles+=("$line")
            fi
        done < <(get_available_profiles "$backup_dir" 2>/dev/null)
    fi
    
    # If existing profiles found, show them
    if [ ${#existing_profiles[@]} -gt 0 ]; then
        echo "Found existing profiles:"
        echo "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê"
        echo "‚îÇ Profile             ‚îÇ Packages    ‚îÇ Last Updated ‚îÇ"
        echo "‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§"
        
        for profile_name in "${existing_profiles[@]}"; do
            local profile_dir="$profiles_dir/$profile_name"
            local pkg_count=0
            local last_date="never"
            
            if [ -f "$profile_dir/Brewfile" ]; then
                pkg_count=$(grep -c "^brew\|^cask\|^mas" "$profile_dir/Brewfile" 2>/dev/null || echo "0")
                last_date=$(stat -f %Sm -t "%Y-%m-%d" "$profile_dir/Brewfile" 2>/dev/null || echo "never")
            fi
            
            printf "‚îÇ %-19s ‚îÇ %-11s ‚îÇ %-12s ‚îÇ\n" "$profile_name" "$pkg_count pkgs" "$last_date"
        done
        
        echo "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"
        echo ""
    fi
    
    # Suggest profile name based on hostname
    local suggested_profile
    suggested_profile=$(suggest_profile_name "$CURRENT_HOSTNAME")
    
    echo "Setup options:"
    echo "1) Use 'default' profile (recommended)"
    if [ ${#existing_profiles[@]} -gt 0 ]; then
        echo "2) Use existing profile from list above"
    fi
    echo "3) Create new profile based on hostname ('$suggested_profile')"
    echo "4) Enter custom profile name"
    echo ""
    
    local max_option=4
    if [ ${#existing_profiles[@]} -eq 0 ]; then
        max_option=3
    fi
    
    echo -n "Select option (1-$max_option): "
    read -r profile_choice
    
    local selected_profile=""
    
    case "$profile_choice" in
        1)
            selected_profile="$DEFAULT_PROFILE"
            ;;
        2)
            if [ ${#existing_profiles[@]} -gt 0 ]; then
                echo ""
                echo "Select profile:"
                local j=1
                for profile_name in "${existing_profiles[@]}"; do
                    echo "$j) $profile_name"
                    ((j++))
                done
                echo -n "Enter choice (1-${#existing_profiles[@]}): "
                read -r profile_selection
                
                if [[ "$profile_selection" =~ ^[0-9]+$ ]] && [ "$profile_selection" -ge 1 ] && [ "$profile_selection" -le ${#existing_profiles[@]} ]; then
                    selected_profile="${existing_profiles[$((profile_selection-1))]}"
                else
                    log_error "Invalid selection. Using 'default' profile."
                    selected_profile="$DEFAULT_PROFILE"
                fi
            else
                log_error "Invalid selection. Using 'default' profile."
                selected_profile="$DEFAULT_PROFILE"
            fi
            ;;
        3)
            selected_profile="$suggested_profile"
            ;;
        4)
            echo -n "Enter profile name: "
            read -r custom_profile
            if validate_profile_name "$custom_profile"; then
                selected_profile="$custom_profile"
            else
                log_error "Invalid profile name. Using 'default' profile."
                selected_profile="$DEFAULT_PROFILE"
            fi
            ;;
        *)
            log_error "Invalid selection. Using 'default' profile."
            selected_profile="$DEFAULT_PROFILE"
            ;;
    esac
    
    # Save the selected profile as default
    save_default_profile "$selected_profile"
    
    echo ""
    log_success "Default profile set to: $selected_profile"
    echo ""
    
    return 0
}

# Function: Interactive storage selection
select_storage_interactive() {
    local -a storages
    local last_index=0
    while IFS= read -r line; do
        storages+=("$line")
    done < <(detect_all_storages)
    
    
    if [ ${#storages[@]} -eq 0 ]; then
        log_warning "No cloud storage services detected."
        log_verbose_plain "Using default local backup: $DEFAULT_BACKUP_DIR"
        echo "local|$DEFAULT_BACKUP_DIR"
        return 0
    fi
    
    if [ ${#storages[@]} -eq 1 ]; then
        # Only one storage available, use it
        local storage="${storages[0]}"
        local method="${storage%%|*}"
        local path="${storage#*|}"
        path="${path%|*}"
        echo "$method|$path"
        return 0
    fi
    
    # Multiple storages available, show selection menu
    echo "" >&2
    log_info "Multiple cloud storage services detected:" >&2
    echo "" >&2
    
    local i=1
    for storage in "${storages[@]}"; do
        local method="${storage%%|*}"
        local path="${storage#*|}"
        local display_name="${path##*|}"
        path="${path%|*}"
        echo "  $i) $display_name ($path)" >&2
        ((i++))
    done
    
    # Check for last used storage
    local last_storage
    if last_storage=$(load_last_storage); then
        local last_method="${last_storage%%|*}"
        local last_path="${last_storage#*|}"
        
        # Find the index of last used storage
        local j=1
        for storage in "${storages[@]}"; do
            local storage_method="${storage%%|*}"
            local storage_path="${storage#*|}"
            storage_path="${storage_path%|*}"
            if [ "$storage_method" = "$last_method" ] && [ "$storage_path" = "$last_path" ]; then
                last_index=$j
                break
            fi
            ((j++))
        done
        
        if [ $last_index -gt 0 ]; then
            echo "" >&2
            log_info "Last used: Option $last_index" >&2
        fi
    fi
    
    echo "" >&2
    if [ $last_index -gt 0 ]; then
        echo -n "Select storage location (1-${#storages[@]}, press Enter for $last_index): " >&2
    else
        echo -n "Select storage location (1-${#storages[@]}, press Enter for 1): " >&2
    fi
    read -r choice
    
    # Handle empty input - show default option
    if [ -z "$choice" ]; then
        if [ $last_index -gt 0 ]; then
            choice=$last_index
            log_info "Using last used option: $choice" >&2
        else
            choice=1
            log_info "Using default option: $choice" >&2
        fi
    # Validate choice
    elif ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#storages[@]} ]; then
        log_error "Invalid selection. Using first available option." >&2
        choice=1
    fi
    
    # Return selected storage
    local selected="${storages[$((choice-1))]}"
    local method="${selected%%|*}"
    local path="${selected#*|}"
    path="${path%|*}"
    
    # Save selection for next time
    save_last_storage "$method" "$path"
    
    echo "$method|$path"
}

# Function: Print main usage
usage() {
    echo "brew-sync: Homebrew package synchronization tool"
    echo ""
    echo "Commands:"
    echo "  backup [profile]              Backup current packages"
    echo "  restore [profile]             Restore packages from backup"
    echo "  status [profile]              Show backup status and available profiles"
    echo "  history [profile]             Show backup history"
    echo "  rollback [profile] [index]    Rollback to previous backup"
    echo "  edit [profile]                Edit profile Brewfile"
    echo "  set <profile>                 Set default profile"
    echo "  remove <profile>              Remove profile"
    echo "  profile                       Profile management (deprecated - use above)"
    echo "  cleanup [options]             Clean up old backup files"
    echo "  update                        Update to latest version"
    echo "  uninstall                     Uninstall brew-sync"
    echo "  help                          Show this help"
    echo ""
    echo "Examples:"
    echo "  brew-sync backup work         # Backup work profile"
    echo "  brew-sync restore --dry-run   # Preview restore"
    echo "  brew-sync status              # Show all profiles"
    echo "  brew-sync edit work           # Edit work profile"
    echo "  brew-sync set work            # Set work as default"
    echo ""
    echo "Note: [profile] is optional - uses default profile if not specified"
    echo ""
    echo "For detailed options and usage:"
    echo "  brew-sync <command> --help    # Show command-specific help"
    echo ""
    echo "Commands with --help support:"
    echo "  backup, restore, status, history, rollback, edit, set, remove, cleanup, update"
}

# Function: Print backup usage
backup_usage() {
    echo "Usage: brew-sync backup [profile] [options]"
    echo ""
    echo "Arguments:"
    echo "  profile              Profile name (optional, defaults to current default)"
    echo ""
    echo "Common options:"
    echo "  -v, --verbose        Show detailed progress information"
    echo "  -d, --dry-run        Preview backup without making changes"
    echo "  --select-storage     Choose storage location interactively (**saves as default**)"
    echo "  --git                Backup to Git repository (temporary)"
    echo "  --icloud             Backup to iCloud Drive (temporary)"
    echo "  --dropbox            Backup to Dropbox (temporary)"
    echo "  --google-drive       Backup to Google Drive (temporary)"
    echo "  --path <path>        Backup to custom path (temporary)"
    echo ""
    echo "Examples:"
    echo "  brew-sync backup                    # Backup to default profile"
    echo "  brew-sync backup work               # Backup to work profile"
    echo "  brew-sync backup --dry-run          # Preview backup changes"
    echo "  brew-sync backup dev --verbose      # Backup dev profile with details"
    echo ""
    echo "Note: Only --select-storage changes your default storage location."
    echo "      The default profile is loaded from ~/.config/brew-sync/default_profile if it exists."
    echo "For all options: brew-sync backup --help-all"
}

# Function: Print backup usage (full)
backup_usage_full() {
    echo "Usage: brew-sync backup [profile] [options]"
    echo ""
    echo "Arguments:"
    echo "  profile              Profile name (optional, defaults to current default)"
    echo ""
    echo "Backup location options:"
    if [[ "$OSTYPE" == "darwin"* ]]; then
        echo "  --icloud             Use iCloud Drive (default on macOS)"
    else
        echo "  --icloud             Use iCloud Drive"
    fi
    echo "  --git                Backup to Git repository"
    echo "  --dropbox            Backup to Dropbox folder"
    echo "  --google-drive       Backup to Google Drive folder"
    echo "  --path <path>        Custom path"
    echo ""
    echo "Backup options:"
    echo "  --select-storage    **Interactively choose storage location (saves as new default)**"
    echo "  --auto-detect       Auto-detect optimal backup location (default)"
    echo "  -h, --help              Show this help"
    echo ""
    echo "**IMPORTANT**: Only --select-storage changes your default storage setting."
    echo "              Other location options are temporary for this backup only."
    echo ""
    echo "Examples:"
    echo "  brew-sync backup                           # Auto-detect optimal location"
    echo "  brew-sync backup --git                     # Backup to Git repository"
    echo "  brew-sync backup --dropbox -p dev          # Backup to Dropbox with dev profile"
    echo "  brew-sync backup --path ~/my-backup        # Custom path"
    echo "  brew-sync backup --path /Volumes/MyUSB/brew-backup  # USB drive"
}

# Function: Print restore usage
restore_usage() {
    echo "Usage: brew-sync restore [profile] [options]"
    echo ""
    echo "Arguments:"
    echo "  profile              Profile to restore (optional, defaults to current default)"
    echo ""
    echo "Where to restore from:"
    echo "  (default)            Last used storage location"
    echo "  --select-storage     Choose location interactively (**saves as default**)"
    echo "  --git, --icloud      Temporary: use specific storage"
    echo "  --dropbox, --path    Temporary: use specific storage"
    echo ""
    echo "Other options:"
    echo "  -d, --dry-run        Preview only (recommended first)"
    echo "  -f, --force          Overwrite existing Brewfile and proceed"
    echo "  --skip-mas           Skip Mac App Store app installation"
    echo "  -v, --verbose        Show detailed installation progress"
    echo "  -l, --list           List available backups"
    echo ""
    echo "Examples:"
    echo "  brew-sync restore --dry-run         # Preview default profile"
    echo "  brew-sync restore                   # Restore default profile"
    echo "  brew-sync restore work              # Restore work profile"
    echo "  brew-sync restore dev --dry-run     # Preview dev profile"
    echo ""
    echo "Note: Only --select-storage changes your default storage location."
    echo "      The default profile is loaded from ~/.config/brew-sync/default_profile if it exists."
    echo "For all options: brew-sync restore --help-all"
}

# Function: Print restore usage (full)
restore_usage_full() {
    echo "Usage: brew-sync restore [profile] [options]"
    echo ""
    echo "Backup source options:"
    echo "  --icloud               Restore from iCloud Drive"
    echo "  --git                  Restore from Git repository"
    echo "  --dropbox              Restore from Dropbox"
    echo "  --google-drive         Restore from Google Drive"
    echo "  --path <path>          Restore from custom path"
    echo "  --select-storage       **Interactively choose storage location (saves as new default)**"
    echo "  --auto-detect          Auto-detect optimal backup location (default)"
    echo ""
    echo "Installation options:"
    echo "  -d, --dry-run          Preview only without actual installation"
    echo "  -f, --force            Overwrite existing Brewfile and proceed"
    echo "  --skip-mas             Skip Mac App Store app installation"
    echo "  -v, --verbose          Verbose output"
    echo "  -l, --list             List available backups"
    echo "  -h, --help              Show this help"
    echo ""
    echo "**IMPORTANT**: Only --select-storage changes your default storage setting."
    echo "              Other source options are temporary for this restore only."
    echo ""
    echo "Examples:"
    echo "  brew-sync restore                     # Auto-detect and restore default profile"
    echo "  brew-sync restore work --git         # Restore work profile from Git repository"
    echo "  brew-sync restore dev --dropbox     # Restore dev profile from Dropbox"
    echo "  brew-sync restore work --path ~/backup  # Restore work profile from custom path"
}

# Function: Auto-detect backup location with smart selection
detect_backup_location() {
    local interactive_mode="$1"  # "interactive" or empty for auto-detect
    
    # Check for first-time setup (no config file exists)
    if [ ! -f "$LAST_STORAGE_FILE" ] && [ "$interactive_mode" != "interactive" ]; then
        log_info "First time running brew-sync..."
        local selection
        selection=$(first_time_setup)
        local method="${selection%%|*}"
        local path="${selection#*|}"
        
        BACKUP_DIR="$path"
        BACKUP_METHOD="$method"
        
        # After storage setup, check for profile setup
        if ! load_default_profile >/dev/null 2>&1; then
            first_time_profile_setup "$BACKUP_DIR"
        fi
        
        return 0
    fi
    
    # Try to use last used storage if available (but not in interactive mode)
    local last_storage
    if [ "$interactive_mode" != "interactive" ] && last_storage=$(load_last_storage); then
        local method="${last_storage%%|*}"
        local path="${last_storage#*|}"
        
        log_verbose_plain "Using last saved storage: $method ($path)"
        BACKUP_DIR="$path"
        BACKUP_METHOD="$method"
        return 0
    fi
    
    # Get all available storages
    local -a storages
    while IFS= read -r line; do
        storages+=("$line")
    done < <(detect_all_storages)
    
    if [ ${#storages[@]} -eq 0 ]; then
        # No cloud storage detected, use local default
        log_warning "No cloud storage services detected."
        log_verbose_plain "Using default local backup: $DEFAULT_BACKUP_DIR"
        BACKUP_DIR="$DEFAULT_BACKUP_DIR"
        BACKUP_METHOD="local"
        return 0
    fi
    
    if [ ${#storages[@]} -eq 1 ] && [ "$interactive_mode" != "interactive" ]; then
        # Only one storage available, use it automatically
        local storage="${storages[0]}"
        local method="${storage%%|*}"
        local path="${storage#*|}"
        path="${path%|*}"
        local display_name="${storage##*|}"
        
        log_info "$display_name detected: $path"
        BACKUP_DIR="$path"
        BACKUP_METHOD="$method"
        
        # Save this choice for future use
        save_last_storage "$method" "$path"
        return 0
    fi
    
    # Multiple storages available or interactive mode requested
    if [ "$interactive_mode" = "interactive" ] || [ ${#storages[@]} -gt 1 ]; then
        local selection
        selection=$(select_storage_interactive)
        local method="${selection%%|*}"
        local path="${selection#*|}"
        
        local display_name=""
        for storage in "${storages[@]}"; do
            local storage_method="${storage%%|*}"
            local storage_path="${storage#*|}"
            storage_path="${storage_path%|*}"
            if [ "$storage_method" = "$method" ] && [ "$storage_path" = "$path" ]; then
                display_name="${storage##*|}"
                break
            fi
        done
        
        log_info "Selected: $display_name ($path)"
        BACKUP_DIR="$path"
        BACKUP_METHOD="$method"
        return 0
    fi
    
    # Fallback to local default
    log_warning "Using default local backup: $DEFAULT_BACKUP_DIR"
    BACKUP_DIR="$DEFAULT_BACKUP_DIR"
    BACKUP_METHOD="local"
}

# Function: Handle Git backup
handle_git_backup() {
    if ! git rev-parse --git-dir &>/dev/null; then
        log_error "Current directory is not a Git repository."
        log_info "To initialize Git repository:"
        log_info "  git init"
        log_info "  git remote add origin <repository-url>"
        exit 1
    fi
    
    local git_root=$(git rev-parse --show-toplevel)
    BACKUP_DIR="$git_root"
    BACKUP_METHOD="git"
    
    log_info "Backing up to Git repository: $git_root"
}

# Function: Analyze and create common packages
analyze_common_packages() {
    local hosts_dir="$1"
    local common_dir="$BACKUP_DIR/common"
    
    # Skip if less than 2 hosts
    local host_count=$(find "$hosts_dir" -maxdepth 1 -type d -name "*" | wc -l)
    if [ "$host_count" -lt 3 ]; then  # 3 because find includes the parent dir
        return 0
    fi
    
    log_info "Analyzing common packages across $((host_count-1)) hosts..."
    
    # Create temporary files
    local temp_all=$(mktemp)
    local temp_common=$(mktemp)
    
    # Collect all packages from all hosts
    find "$hosts_dir" -name "Brewfile" -exec cat {} \; | sort > "$temp_all"
    
    # Find packages that appear in 80% or more of hosts
    local threshold=$(((host_count-1) * 80 / 100))
    if [ "$threshold" -lt 2 ]; then
        threshold=2
    fi
    
    uniq -c "$temp_all" | awk -v th="$threshold" '$1 >= th {$1=""; print substr($0,2)}' > "$temp_common"
    
    if [ -s "$temp_common" ]; then
        mkdir -p "$common_dir"
        
        # Create common Brewfile with header
        {
            echo "# Common packages across all Macs"
            echo "# Auto-generated on $(date "+%Y-%m-%d %H:%M:%S")"
            echo "# Threshold: $threshold/$((host_count-1)) hosts"
            echo ""
            cat "$temp_common"
        } > "$common_dir/Brewfile"
        
        local common_count=$(wc -l < "$temp_common")
        log_success "Created common Brewfile with $common_count packages"
        
        # Remove common packages from individual host files
        for host_dir in "$hosts_dir"/*; do
            if [ -d "$host_dir" ] && [ -f "$host_dir/Brewfile" ]; then
                local host_brewfile="$host_dir/Brewfile"
                local temp_host=$(mktemp)
                
                # Keep only packages not in common
                comm -23 <(sort "$host_brewfile") <(sort "$temp_common") > "$temp_host"
                
                # Add header to host-specific file
                {
                    echo "# Host-specific packages for $(basename "$host_dir")"
                    echo "# Common packages are inherited from common/Brewfile"
                    echo "# Last updated: $(date "+%Y-%m-%d %H:%M:%S")"
                    echo ""
                    cat "$temp_host"
                } > "$host_brewfile"
                
                rm -f "$temp_host"
            fi
        done
    fi
    
    rm -f "$temp_all" "$temp_common"
}

# Function: Decompress backup file if needed
decompress_backup_file() {
    local source_file="$1"
    local temp_dir="$2"
    
    # If file doesn't exist, try compressed version
    if [ ! -f "$source_file" ] && [ -f "$source_file.gz" ]; then
        log_info "Found compressed backup: $(basename "$source_file.gz")"
        local temp_file="$temp_dir/$(basename "$source_file")"
        gunzip -c "$source_file.gz" > "$temp_file"
        echo "$temp_file"
        return 0
    elif [ -f "$source_file" ]; then
        echo "$source_file"
        return 0
    else
        return 1
    fi
}

# Function: Get latest backup file (compressed or uncompressed)
get_latest_backup_file() {
    local host_dir="$1"
    local base_name="$2"  # e.g., "Brewfile"
    
    # Check if current file exists
    if [ -f "$host_dir/$base_name" ]; then
        echo "$host_dir/$base_name"
        return 0
    fi
    
    # Find latest timestamped backup (compressed or uncompressed)
    local latest_file=""
    local latest_timestamp=0
    
    # Check uncompressed files
    for file in "$host_dir"/${base_name}_*; do
        # Skip if glob didn't match any files
        [ -f "$file" ] || continue
        # Skip compressed files
        [[ "$file" =~ \.gz$ ]] && continue
        
        local timestamp=$(basename "$file" | grep -o '[0-9]\{8\}_[0-9]\{6\}')
        if [ -n "$timestamp" ]; then
            local file_timestamp=$(echo "$timestamp" | tr -d '_')
            if [ "$file_timestamp" -gt "$latest_timestamp" ]; then
                latest_timestamp="$file_timestamp"
                latest_file="$file"
            fi
        fi
    done
    
    # Check compressed files
    for file in "$host_dir"/${base_name}_*.gz; do
        # Skip if glob didn't match any files
        [ -f "$file" ] || continue
        
        local timestamp=$(basename "$file" .gz | grep -o '[0-9]\{8\}_[0-9]\{6\}')
        if [ -n "$timestamp" ]; then
            local file_timestamp=$(echo "$timestamp" | tr -d '_')
            if [ "$file_timestamp" -gt "$latest_timestamp" ]; then
                latest_timestamp="$file_timestamp"
                latest_file="$file"
            fi
        fi
    done
    
    if [ -n "$latest_file" ]; then
        echo "$latest_file"
        return 0
    else
        return 1
    fi
}

# Function: Combine common and host-specific packages
combine_packages() {
    local host_dir="$1"
    local output_file="$2"
    local common_file="$BACKUP_DIR/common/Brewfile"
    local host_file="$host_dir/Brewfile"
    local temp_dir=$(mktemp -d)
    
    # Handle compressed host file if needed
    local actual_host_file="$host_file"
    
    # If main Brewfile doesn't exist, try compressed version
    if [ ! -f "$host_file" ] && [ -f "$host_file.gz" ]; then
        log_info "Found compressed backup: $(basename "$host_file.gz")"
        actual_host_file="$temp_dir/$(basename "$host_file")"
        gunzip -c "$host_file.gz" > "$actual_host_file"
    elif [ ! -f "$host_file" ]; then
        # Try to find latest backup file
        local latest_compressed=$(ls -t "$host_dir"/Brewfile_*.gz 2>/dev/null | head -1)
        if [ -n "$latest_compressed" ] && [ -f "$latest_compressed" ]; then
            log_warning "Using latest compressed backup: $(basename "$latest_compressed")"
            actual_host_file="$temp_dir/$(basename "$latest_compressed" .gz)"
            gunzip -c "$latest_compressed" > "$actual_host_file"
        else
            # No backup files found
            actual_host_file=""
        fi
    fi
    
    {
        echo "# Combined Brewfile for $(basename "$host_dir")"
        echo "# Generated on $(date "+%Y-%m-%d %H:%M:%S")"
        echo ""
        
        if [ -f "$common_file" ]; then
            echo "# === Common packages ==="
            grep -v '^#' "$common_file" | grep -v '^$'
            echo ""
        fi
        
        if [ -n "$actual_host_file" ] && [ -f "$actual_host_file" ]; then
            echo "# === Host-specific packages ==="
            grep -v '^#' "$actual_host_file" | grep -v '^$'
        fi
    } > "$output_file"
    
    # Cleanup temporary decompressed file if created
    if [[ "$actual_host_file" =~ ^"$temp_dir" ]]; then
        rm -f "$actual_host_file"
    fi
    rm -rf "$temp_dir"
}

# Function: Validate profile exists
validate_profile_exists() {
    local profile_name="$1"
    local backup_dir="$2"
    local profiles_dir="$backup_dir/$PROFILES_DIR"
    
    if [ ! -d "$profiles_dir/$profile_name" ]; then
        return 1
    fi
    
    return 0
}

# Function: Profile management
manage_profiles() {
    local command="$1"
    [ $# -gt 0 ] && shift
    
    case "$command" in
        "")
            # Show current default profile and available commands
            if [ -f "$DEFAULT_PROFILE_FILE" ]; then
                echo "Current default profile: $(cat "$DEFAULT_PROFILE_FILE")"
            else
                echo "No default profile set"
                echo "Use 'brew-sync set PROFILE' to set a default profile"
            fi
            echo ""
            echo "Profile management commands have moved to top level:"
            echo "  brew-sync edit [profile]     # Edit profile"
            echo "  brew-sync set <profile>      # Set default profile"
            echo "  brew-sync remove <profile>   # Remove profile"
            echo "  brew-sync status [profile]   # View profile status"
            ;;
        help|--help|-h)
            profile_usage
            ;;
        *)
            echo "Profile management commands have moved to top level:"
            echo "  brew-sync edit [profile]     # Edit profile"
            echo "  brew-sync set <profile>      # Set default profile"  
            echo "  brew-sync remove <profile>   # Remove profile"
            echo "  brew-sync status [profile]   # View profile status"
            echo ""
            log_error "Unknown profile command: $command"
            exit 1
            ;;
    esac
}

# Function: List profiles
list_profiles() {
    # Auto-detect backup location for listing
    detect_backup_location 2>/dev/null || BACKUP_DIR="$DEFAULT_BACKUP_DIR"
    
    local profiles_dir="$BACKUP_DIR/$PROFILES_DIR"
    
    echo "Available profiles:"
    echo ""
    
    if [ -d "$profiles_dir" ]; then
        local profile_count=0
        echo "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê"
        echo "‚îÇ Profile             ‚îÇ Packages    ‚îÇ Last Updated ‚îÇ"
        echo "‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§"
        
        for profile_dir in "$profiles_dir"/*; do
            if [ -d "$profile_dir" ]; then
                local profile_name
                profile_name=$(basename "$profile_dir")
                local pkg_count=0
                local last_date="never"
                
                if [ -f "$profile_dir/Brewfile" ]; then
                    pkg_count=$(grep -c "^brew\|^cask\|^mas" "$profile_dir/Brewfile" 2>/dev/null || echo "0")
                    last_date=$(stat -f %Sm -t "%Y-%m-%d" "$profile_dir/Brewfile" 2>/dev/null || echo "never")
                fi
                
                printf "‚îÇ %-19s ‚îÇ %-11s ‚îÇ %-12s ‚îÇ\n" "$profile_name" "$pkg_count pkgs" "$last_date"
                ((profile_count++))
            fi
        done
        
        echo "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"
        echo ""
        echo "Found $profile_count profile(s)"
    else
        echo "  No profiles found."
        echo ""
        echo "  To create a profile, run:"
        echo "    brew-sync backup --profile PROFILE_NAME"
    fi
}

# Function: Set profile (legacy compatibility message)
set_profile() {
    local profile_name="$1"
    
    # Handle help
    if [[ "$1" == "--help" || "$1" == "-h" || -z "$1" ]]; then
        echo "Usage: brew-sync set <profile>"
        echo ""
        echo "Set profile as default"
        echo ""
        echo "Arguments:"
        echo "  profile              Profile name to set as default (required)"
        echo ""
        echo "Examples:"
        echo "  brew-sync set work           # Set work as default profile"
        echo "  brew-sync set default        # Set default as default profile"
        exit 0
    fi
    
    # Validate profile name
    if ! validate_profile_name "$profile_name"; then
        log_error "Invalid profile name: '$profile_name'"
        log_info "Profile names must be alphanumeric with hyphens/underscores only (max 50 chars)"
        exit 1
    fi
    
    # Auto-detect backup location
    if ! detect_backup_location 2>/dev/null; then
        BACKUP_DIR="$DEFAULT_BACKUP_DIR"
    fi
    
    # Check if profile exists
    local profile_dir="$BACKUP_DIR/profiles/$profile_name"
    if [ ! -d "$profile_dir" ] || [ ! -f "$profile_dir/Brewfile" ]; then
        log_error "Profile '$profile_name' does not exist"
        echo "Use 'brew-sync status' to see available profiles"
        echo "Use 'brew-sync backup $profile_name' to create it"
        exit 1
    fi
    
    # Save as default profile
    save_default_profile "$profile_name"
    log_success "Set '$profile_name' as default profile"
}

# Function: Remove profile
remove_profile() {
    local profile_name="$1"
    
    # Handle help
    if [[ "$1" == "--help" || "$1" == "-h" || -z "$1" ]]; then
        echo "Usage: brew-sync remove <profile>"
        echo ""
        echo "Remove profile (except 'default')"
        echo ""
        echo "Arguments:"
        echo "  profile              Profile name to remove (required)"
        echo ""
        echo "Examples:"
        echo "  brew-sync remove work        # Remove work profile"
        echo "  brew-sync remove old         # Remove old profile"
        echo ""
        echo "Note: Cannot remove the 'default' profile"
        exit 0
    fi
    
    if [ "$profile_name" = "$DEFAULT_PROFILE" ]; then
        log_error "Cannot remove the default profile"
        exit 1
    fi
    
    # Auto-detect backup location
    detect_backup_location 2>/dev/null || BACKUP_DIR="$DEFAULT_BACKUP_DIR"
    
    local profile_dir="$BACKUP_DIR/$PROFILES_DIR/$profile_name"
    
    if [ -d "$profile_dir" ]; then
        echo "This will permanently delete profile '$profile_name' and all its backups."
        echo -n "Are you sure? (y/N): "
        read -r response
        
        if [[ "$response" =~ ^[Yy]$ ]]; then
            rm -rf "$profile_dir"
            log_success "Profile '$profile_name' removed"
        else
            log_info "Profile removal cancelled"
        fi
    else
        log_error "Profile '$profile_name' not found"
        echo ""
        echo "Available profiles:"
        get_available_profiles
        exit 1
    fi
}


# Function: Parse Brewfile and extract packages by type
parse_brewfile() {
    local brewfile="$1"
    local output_file="$2"
    
    # Clear the output file
    > "$output_file"
    
    if [ ! -f "$brewfile" ]; then
        return 0
    fi
    
    # Parse packages and write to output file in format: type:package
    while IFS= read -r line; do
        if [[ $line =~ ^[[:space:]]*brew[[:space:]]+\"([^\"]+)\" ]]; then
            echo "brew:${BASH_REMATCH[1]}" >> "$output_file"
        elif [[ $line =~ ^[[:space:]]*cask[[:space:]]+\"([^\"]+)\" ]]; then
            echo "cask:${BASH_REMATCH[1]}" >> "$output_file"
        elif [[ $line =~ ^[[:space:]]*mas[[:space:]]+\"([^\"]+)\" ]]; then
            echo "mas:${BASH_REMATCH[1]}" >> "$output_file"
        fi
    done < "$brewfile"
}

# Function: Compare two Brewfiles and identify differences
compare_brewfiles() {
    local old_brewfile="$1"
    local new_brewfile="$2"
    local output_file="$3"
    
    # Create temporary files for parsing
    local temp_dir=$(mktemp -d)
    local old_parsed="$temp_dir/old.txt"
    local new_parsed="$temp_dir/new.txt"
    
    # Parse both files
    parse_brewfile "$old_brewfile" "$old_parsed"
    parse_brewfile "$new_brewfile" "$new_parsed"
    
    # Clear output file and write sections
    > "$output_file"
    echo "# Added packages" >> "$output_file"
    
    # Find added packages
    while IFS=: read -r type package; do
        if ! grep -q "^$type:$package$" "$old_parsed" 2>/dev/null; then
            echo "added:$type:$package" >> "$output_file"
        fi
    done < "$new_parsed"
    
    echo "# Removed packages" >> "$output_file"
    
    # Find removed packages
    while IFS=: read -r type package; do
        if ! grep -q "^$type:$package$" "$new_parsed" 2>/dev/null; then
            echo "removed:$type:$package" >> "$output_file"
        fi
    done < "$old_parsed"
    
    # Cleanup
    rm -rf "$temp_dir"
}

# Function: Show changes preview to user
show_changes_preview() {
    local changes_file="$1"
    local profile_name="$2"
    
    local has_changes=false
    local has_installs=false
    local has_removes=false
    
    echo ""
    echo -e "${BLUE}Changes to be applied to profile '${profile_name}':${NC}"
    echo ""
    
    # Check if we have any added packages
    if grep -q "^added:" "$changes_file" 2>/dev/null; then
        has_installs=true
        has_changes=true
    fi
    
    # Check if we have any removed packages  
    if grep -q "^removed:" "$changes_file" 2>/dev/null; then
        has_removes=true
        has_changes=true
    fi
    
    # Show installations
    if [ "$has_installs" = true ]; then
        echo -e "${GREEN}INSTALL:${NC}"
        while IFS=: read -r action type package; do
            if [ "$action" = "added" ]; then
                echo -e "  ${GREEN}+${NC} $type \"$package\""
            fi
        done < "$changes_file"
        echo ""
    fi
    
    # Show removals
    if [ "$has_removes" = true ]; then
        echo -e "${RED}REMOVE:${NC}"
        while IFS=: read -r action type package; do
            if [ "$action" = "removed" ]; then
                echo -e "  ${RED}-${NC} $type \"$package\""
            fi
        done < "$changes_file"
        echo ""
    fi
    
    if [ "$has_changes" = false ]; then
        echo -e "${YELLOW}No changes detected.${NC}"
        echo ""
        return 1
    fi
    
    return 0
}

# Function: Apply package changes to system
apply_package_changes() {
    local changes_file="$1"
    
    local success=true
    
    # Process all changes from the changes file
    while IFS=: read -r action type package; do
        case "$action" in
            "added")
                case "$type" in
                    "brew")
                        log_info "Installing brew package: $package"
                        if ! brew install "$package"; then
                            log_error "Failed to install brew package: $package"
                            success=false
                        fi
                        ;;
                    "cask")
                        log_info "Installing cask: $package"
                        if ! brew install --cask "$package"; then
                            log_error "Failed to install cask: $package"
                            success=false
                        fi
                        ;;
                    "mas")
                        log_warning "mas install not automated for: $package (please install manually from App Store)"
                        ;;
                esac
                ;;
            "removed")
                case "$type" in
                    "brew")
                        log_info "Removing brew package: $package"
                        if ! brew uninstall "$package"; then
                            log_error "Failed to remove brew package: $package"
                            success=false
                        fi
                        ;;
                    "cask")
                        log_info "Removing cask: $package"
                        if ! brew uninstall --cask "$package"; then
                            log_error "Failed to remove cask: $package"
                            success=false
                        fi
                        ;;
                    "mas")
                        log_warning "mas uninstall not automated for: $package (please uninstall manually)"
                        ;;
                esac
                ;;
        esac
    done < "$changes_file"
    
    if [ "$success" = true ]; then
        return 0
    else
        return 1
    fi
}

# Function: Edit profile
edit_profile() {
    local profile_name="$1"
    
    # Handle help
    if [[ "$1" == "--help" || "$1" == "-h" ]]; then
        echo "Usage: brew-sync edit [profile]"
        echo ""
        echo "Edit profile Brewfile with default editor"
        echo ""
        echo "Arguments:"
        echo "  profile              Profile to edit (optional)"
        echo ""
        echo "Examples:"
        echo "  brew-sync edit               # Edit default profile or select one"
        echo "  brew-sync edit work          # Edit work profile"
        exit 0
    fi
    
    # Auto-detect backup location
    if ! detect_backup_location 2>/dev/null; then
        log_error "Could not detect backup location. Please run backup first."
        exit 1
    fi
    
    # If no default profile is set and no profile specified, prompt for selection
    if [ -z "$profile_name" ]; then
        if [ -f "$DEFAULT_PROFILE_FILE" ]; then
            profile_name=$(cat "$DEFAULT_PROFILE_FILE")
            log_verbose_plain "Using default profile: $profile_name"
        else
            log_info "No default profile set. Please select a profile to edit."
            echo ""
            profile_name=$(select_profile_for_edit "$BACKUP_DIR" "$CURRENT_HOSTNAME")
            
            # Set the selected profile as default
            save_default_profile "$profile_name"
            log_success "Set '$profile_name' as default profile"
        fi
    else
        # Validate profile exists
        if ! validate_profile_exists "$profile_name" "$BACKUP_DIR"; then
            log_error "Profile '$profile_name' does not exist"
            echo "Use 'brew-sync list' to see available profiles"
            exit 1
        fi
    fi
    
    local profile_dir="$BACKUP_DIR/$PROFILES_DIR/$profile_name"
    local brewfile_path="$profile_dir/Brewfile"
    
    # Create profile directory if it doesn't exist
    if [ ! -d "$profile_dir" ]; then
        mkdir -p "$profile_dir"
    fi
    
    # Create empty Brewfile if it doesn't exist
    if [ ! -f "$brewfile_path" ]; then
        log_info "Creating new Brewfile for profile '$profile_name'"
        cat > "$brewfile_path" <<EOF
# Homebrew packages for profile: $profile_name
# Generated on $(date)
# 
# Edit this file to add/remove packages:
# - brew "package-name"        # for CLI tools
# - cask "app-name"           # for GUI applications  
# - mas "app-name", id: 12345 # for Mac App Store apps
#
# You can find package names at:
# - https://formulae.brew.sh (for brew packages)
# - https://github.com/Homebrew/homebrew-cask/tree/master/Casks (for cask apps)

EOF
    fi
    
    # Create temporary directory for editing
    local temp_dir=$(mktemp -d)
    local temp_brewfile="$temp_dir/Brewfile"
    local original_brewfile="$temp_dir/Brewfile.original"
    
    # Copy original Brewfile to temp directory
    if ! cp "$brewfile_path" "$temp_brewfile"; then
        log_error "Failed to create temporary copy of Brewfile"
        rm -rf "$temp_dir"
        exit 1
    fi
    
    # Keep a copy of the original for comparison
    cp "$temp_brewfile" "$original_brewfile"
    
    # Determine editor to use
    local editor="${EDITOR:-${VISUAL:-nano}}"
    
    log_info "Editing profile '$profile_name'"
    log_verbose "Editor: $editor"
    log_verbose "Temporary editing - changes applied after confirmation"
    echo ""
    echo "Press any key to continue..."
    read -r -n 1
    
    # Open the temporary Brewfile in the editor
    if "$editor" "$temp_brewfile"; then
        log_success "Brewfile edited successfully"
        
        # Compare changes
        local changes_file="$temp_dir/changes.txt"
        
        compare_brewfiles "$original_brewfile" "$temp_brewfile" "$changes_file"
        
        # Show preview and get user confirmation
        if show_changes_preview "$changes_file" "$profile_name"; then
            echo ""
            echo -n "Apply these changes? [y/N]: "
            read -r response
            
            if [[ "$response" =~ ^[Yy] ]]; then
                log_info "Applying changes to your system..."
                
                # Apply package changes
                if apply_package_changes "$changes_file"; then
                    log_success "Package changes applied successfully"
                    
                    # Copy the edited Brewfile back to profile directory
                    if cp "$temp_brewfile" "$brewfile_path"; then
                        log_success "Profile '$profile_name' updated with your changes"
                        
                        # Update backup metadata
                        local metadata_file="$profile_dir/metadata.json"
                        if [ -f "$metadata_file" ]; then
                            # Update existing metadata
                            local temp_metadata=$(mktemp)
                            jq '.last_updated = now | .source = "edited"' "$metadata_file" > "$temp_metadata"
                            mv "$temp_metadata" "$metadata_file"
                        else
                            # Create new metadata
                            cat > "$metadata_file" <<EOF
{
  "profile_name": "$profile_name",
  "created": $(date +%s),
  "last_updated": $(date +%s),
  "source": "edited",
  "hostname": "$CURRENT_HOSTNAME"
}
EOF
                        fi
                        
                        log_success "Profile '$profile_name' synchronized successfully"
                    else
                        log_error "Failed to save edited Brewfile to profile"
                    fi
                else
                    log_error "Some package changes failed. Profile not updated."
                fi
            else
                log_info "Changes discarded. Profile unchanged."
            fi
        else
            log_plain "No changes detected. Profile unchanged."
        fi
        
        # Clean up temporary directory
        rm -rf "$temp_dir"
    else
        log_error "Editor exited with error. Changes discarded."
        rm -rf "$temp_dir"
        exit 1
    fi
}

# Function: Profile usage
profile_usage() {
    echo "Usage: brew-sync profile [command] [options]"
    echo ""
    echo "Commands:"
    echo "  set <profile>           Set profile as default"
    echo "  get                     Get current default profile (for scripting)"
    echo "  edit [profile]          Edit profile Brewfile with default editor"
    echo "  remove <profile>        Remove profile (except 'default')"
    echo ""
    echo "Examples:"
    echo "  brew-sync profile set work"
    echo "  brew-sync profile get"
    echo "  brew-sync profile edit work"
    echo "  brew-sync profile edit              # Edit default profile or select one"
    echo "  brew-sync profile remove old-profile"
    echo ""
    echo "To view/create/use profiles:"
    echo "  brew-sync status                         # Show all profiles"
    echo "  brew-sync backup work                    # Create/update work profile"
    echo "  brew-sync restore work                   # Restore from work profile"
    echo ""
    echo "Note: Profiles are directories that store independent backup sets."
    echo "      Each profile maintains its own Brewfile and metadata."
}

# Function: Calculate file hash for deduplication
calculate_file_hash() {
    local file="$1"
    if [ -f "$file" ]; then
        shasum -a 256 "$file" | cut -d' ' -f1
    fi
}

# Function: Create deduplication storage
create_dedup_storage() {
    local backup_dir="$1"
    local dedup_dir="$backup_dir/.dedup"
    
    mkdir -p "$dedup_dir/objects"
    mkdir -p "$dedup_dir/refs"
    
    echo "$dedup_dir"
}

# Function: Store file with deduplication
store_deduplicated_file() {
    local source_file="$1"
    local target_path="$2"
    local backup_dir="$3"
    
    local dedup_dir=$(create_dedup_storage "$backup_dir")
    local file_hash=$(calculate_file_hash "$source_file")
    local object_file="$dedup_dir/objects/$file_hash"
    
    # Store original file if not exists
    if [ ! -f "$object_file" ]; then
        cp "$source_file" "$object_file"
        log_info "Stored deduplicated object: ${file_hash:0:8}..."
    fi
    
    # Create reference (symlink or copy)
    local ref_file="$dedup_dir/refs/$(basename "$target_path")_$(date +%Y%m%d_%H%M%S)"
    echo "$file_hash|$target_path|$(date +%s)" > "$ref_file"
    
    # Create timestamped backup using symlink to save space
    if [ -L "$target_path" ]; then
        rm "$target_path"
    elif [ -f "$target_path" ]; then
        local backup_name="${target_path}_$(date +%Y%m%d_%H%M%S)"
        if [ ! -f "$backup_name" ]; then
            # Check if we already have this content
            local existing_hash=$(calculate_file_hash "$target_path")
            local existing_object="$dedup_dir/objects/$existing_hash"
            if [ -f "$existing_object" ]; then
                ln -s "$(realpath --relative-to="$(dirname "$backup_name")" "$existing_object")" "$backup_name"
            else
                mv "$target_path" "$backup_name"
            fi
        fi
    fi
    
    # Create symlink to deduplicated object
    ln -s "$(realpath --relative-to="$(dirname "$target_path")" "$object_file")" "$target_path"
}

# Function: Compress old backup files
compress_old_backups() {
    local backup_dir="$1"
    local compress_after_days="${2:-30}"
    local archive_after_days="${3:-365}"
    
    log_info "Compressing backups older than $compress_after_days days..."
    
    # Find files older than compress_after_days for gzip compression
    if [ "$compress_after_days" -eq 0 ]; then
        # Special case: compress all files immediately
        find "$backup_dir" -name "Brewfile_*" -type f ! -name "*.gz" ! -name "*.tar.gz" | while read -r file; do
            if [ -f "$file" ]; then
                gzip "$file"
                log_info "Compressed: $(basename "$file")"
            fi
        done
    else
        # Normal case: compress files older than specified days
        find "$backup_dir" -name "Brewfile_*" -type f -mtime +$compress_after_days ! -name "*.gz" ! -name "*.tar.gz" | while read -r file; do
            if [ -f "$file" ]; then
                gzip "$file"
                log_info "Compressed: $(basename "$file")"
            fi
        done
    fi
    
    # Find files older than archive_after_days for tar.gz archiving
    if [ "$archive_after_days" -gt "$compress_after_days" ]; then
        local archive_dir="$backup_dir/.archive"
        mkdir -p "$archive_dir"
        
        local cutoff_date=$(date -j -v-${archive_after_days}d +%Y%m%d)
        
        find "$backup_dir" -name "Brewfile_*.gz" -type f | while read -r file; do
            local file_date=$(basename "$file" | grep -o '[0-9]\{8\}' | head -1)
            if [ -n "$file_date" ] && [ "$file_date" -lt "$cutoff_date" ]; then
                local year=${file_date:0:4}
                local archive_file="$archive_dir/backups_$year.tar.gz"
                
                # Add to yearly archive
                tar -czf "$archive_file.tmp" -C "$(dirname "$file")" "$(basename "$file")" 2>/dev/null || {
                    # If archive doesn't exist, create new one
                    tar -czf "$archive_file.tmp" -C "$(dirname "$file")" "$(basename "$file")"
                }
                
                # If archive already exists, append to it
                if [ -f "$archive_file" ]; then
                    tar -czf "$archive_file.new" --concatenate "$archive_file" "$archive_file.tmp"
                    mv "$archive_file.new" "$archive_file"
                    rm "$archive_file.tmp"
                else
                    mv "$archive_file.tmp" "$archive_file"
                fi
                
                rm "$file"
                log_info "Archived: $(basename "$file") -> backups_$year.tar.gz"
            fi
        done
    fi
}

# Function: Remove duplicate backup files
remove_duplicate_backups() {
    local directory="$1"
    local temp_hashes=$(mktemp)
    local temp_duplicates=$(mktemp)
    
    log_info "Scanning for duplicate backups in $(basename "$directory")..."
    
    # Calculate hashes for all backup files (both old and new formats)
    find "$directory" \( -name "Brewfile_*" -o -name "Brewfile" \) -type f ! -name "*.gz" | while read -r file; do
        local hash=$(calculate_file_hash "$file")
        echo "$hash|$file" >> "$temp_hashes"
    done
    
    # Find duplicates (same hash, different files)
    sort "$temp_hashes" | awk -F'|' '
    {
        if (seen[$1]) {
            print $2 " (duplicate of " seen[$1] ")"
        } else {
            seen[$1] = $2
        }
    }' > "$temp_duplicates"
    
    local duplicate_count=0
    while IFS= read -r line; do
        if [ -n "$line" ]; then
            local file_to_remove=$(echo "$line" | cut -d' ' -f1)
            if [ -f "$file_to_remove" ]; then
                rm "$file_to_remove"
                log_info "Removed duplicate: $(basename "$file_to_remove")"
                ((duplicate_count++))
            fi
        fi
    done < "$temp_duplicates"
    
    if [ "$duplicate_count" -gt 0 ]; then
        log_success "Removed $duplicate_count duplicate backup files"
    else
        log_info "No duplicate backup files found"
    fi
    
    rm -f "$temp_hashes" "$temp_duplicates"
}

# Function: Cleanup usage
cleanup_usage() {
    echo "Usage: brew-sync cleanup [options]"
    echo ""
    echo "Options:"
    echo "  --compress-after <days>  Compress backups older than N days (default: 30)"
    echo "  --archive-after <days>   Archive backups older than N days (default: 365)"
    echo "  --remove-duplicates      Remove duplicate backup files"
    echo "  --keep-history <count>   Keep only N recent backups per profile (default: 10)"
    echo "  --dry-run               Show what would be cleaned up without doing it"
    echo "  --all                   Perform all cleanup operations"
    echo "  -h, --help              Show this help"
    echo ""
    echo "Examples:"
    echo "  brew-sync cleanup                              # Default cleanup (compress + dedup)"
    echo "  brew-sync cleanup --compress-after 14         # Compress after 14 days"
    echo "  brew-sync cleanup --keep-history 5            # Keep only 5 recent backups per profile"
    echo "  brew-sync cleanup --dry-run                   # Preview cleanup actions"
    echo "  brew-sync cleanup --all                       # Full cleanup with archiving"
    echo ""
    echo "Storage optimization:"
    echo "  ‚Ä¢ Duplicate detection uses SHA256 hashes"
    echo "  ‚Ä¢ Compression uses gzip (typically 80-90% reduction)"
    echo "  ‚Ä¢ Archiving groups old backups by year"
}

# Function: Cleanup implementation
do_cleanup() {
    local COMPRESS_AFTER=30
    local ARCHIVE_AFTER=365
    local REMOVE_DUPLICATES=true
    local DRY_RUN=false
    local DO_COMPRESSION=true
    local DO_ARCHIVING=false
    local KEEP_HISTORY=10
    
    # Parse cleanup arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --compress-after)
                COMPRESS_AFTER="$2"
                shift 2
                ;;
            --archive-after)
                ARCHIVE_AFTER="$2"
                DO_ARCHIVING=true
                shift 2
                ;;
            --remove-duplicates)
                REMOVE_DUPLICATES=true
                DO_COMPRESSION=false
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --keep-history)
                KEEP_HISTORY="$2"
                shift 2
                ;;
            --all)
                REMOVE_DUPLICATES=true
                DO_COMPRESSION=true
                DO_ARCHIVING=true
                shift
                ;;
            -h|--help)
                cleanup_usage
                exit 0
                ;;
            *)
                log_error "Unknown cleanup option: $1"
                cleanup_usage
                exit 1
                ;;
        esac
    done
    
    # Auto-detect backup location
    detect_backup_location 2>/dev/null || BACKUP_DIR="$DEFAULT_BACKUP_DIR"
    
    if [ ! -d "$BACKUP_DIR" ]; then
        log_error "Backup directory not found: $BACKUP_DIR"
        exit 1
    fi
    
    log_info "Starting cleanup of backup directory: $BACKUP_DIR"
    
    if [ "$DRY_RUN" = true ]; then
        log_warning "DRY RUN mode - no files will be modified"
    fi
    
    # Calculate current storage usage
    local initial_size=$(du -sh "$BACKUP_DIR" 2>/dev/null | cut -f1)
    log_info "Current backup size: $initial_size"
    
    # 1. Remove duplicate backups from all profiles
    if [ "$REMOVE_DUPLICATES" = true ]; then
        if [ "$DRY_RUN" = false ]; then
            local profiles_dir="$BACKUP_DIR/$PROFILES_DIR"
            if [ -d "$profiles_dir" ]; then
                for profile_dir in "$profiles_dir"/*; do
                    if [ -d "$profile_dir" ]; then
                        remove_duplicate_backups "$profile_dir"
                    fi
                done
            fi
            
            # Also clean up old hosts directory if it exists
            if [ -d "$BACKUP_DIR/hosts" ]; then
                remove_duplicate_backups "$BACKUP_DIR/hosts"
            fi
            if [ -d "$BACKUP_DIR/merged" ]; then
                remove_duplicate_backups "$BACKUP_DIR/merged"
            fi
        else
            log_info "[DRY-RUN] Would scan for and remove duplicate backup files across all profiles"
        fi
    fi
    
    # 2. Compress old backups
    if [ "$DO_COMPRESSION" = true ]; then
        if [ "$DRY_RUN" = false ]; then
            compress_old_backups "$BACKUP_DIR" "$COMPRESS_AFTER" "$ARCHIVE_AFTER"
        else
            log_info "[DRY-RUN] Would compress backups older than $COMPRESS_AFTER days"
            if [ "$DO_ARCHIVING" = true ]; then
                log_info "[DRY-RUN] Would archive backups older than $ARCHIVE_AFTER days"
            fi
        fi
    fi
    
    # 3. Clean up empty directories
    if [ "$DRY_RUN" = false ]; then
        find "$BACKUP_DIR" -type d -empty -delete 2>/dev/null || true
    else
        local empty_dirs=$(find "$BACKUP_DIR" -type d -empty 2>/dev/null | wc -l)
        if [ "$empty_dirs" -gt 0 ]; then
            log_info "[DRY-RUN] Would remove $empty_dirs empty directories"
        fi
    fi
    
    # Show final results
    if [ "$DRY_RUN" = false ]; then
        local final_size=$(du -sh "$BACKUP_DIR" 2>/dev/null | cut -f1)
        log_success "Cleanup completed!"
        log_info "Storage before: $initial_size"
        log_info "Storage after:  $final_size"
        
        # Calculate savings if possible
        if command -v numfmt >/dev/null 2>&1; then
            local initial_bytes=$(du -sb "$BACKUP_DIR" 2>/dev/null | cut -f1)
            local savings_percent=$(( (initial_bytes > 0) ? (100 - ($(du -sb "$BACKUP_DIR" 2>/dev/null | cut -f1) * 100 / initial_bytes)) : 0 ))
            if [ "$savings_percent" -gt 0 ]; then
                log_info "Space saved: ~$savings_percent%"
            fi
        fi
    else
        log_info "[DRY-RUN] Use without --dry-run to perform actual cleanup"
    fi
}

# Function: Resolve profile to host
resolve_profile() {
    local profile_name="$1"
    local profiles_dir="$BACKUP_DIR/profiles"
    local profile_link="$profiles_dir/$profile_name"
    
    if [ -L "$profile_link" ]; then
        local target=$(readlink "$profile_link")
        echo "$(basename "$target")"
        return 0
    else
        # Return the original name if no profile alias exists
        echo "$profile_name"
        return 1
    fi
}

# Function: List available backups
list_backups() {
    # Check for migration first
    if check_migration_needed "$BACKUP_DIR"; then
        log_warning "Migration needed. Run 'brew-sync backup' or 'brew-sync restore' to trigger automatic migration."
        echo ""
        
        # Show legacy host-based backups
        if [ -d "$BACKUP_DIR/hosts" ]; then
            echo "Legacy host-based backups (need migration):"
            for host_dir in "$BACKUP_DIR/hosts"/*; do
                if [ -d "$host_dir" ] && [ -f "$host_dir/Brewfile" ]; then
                    local hostname=$(basename "$host_dir")
                    if [ -f "$host_dir/backup_info.txt" ]; then
                        local last_backup=$(grep "Last backup:" "$host_dir/backup_info.txt" | cut -d: -f2- | xargs)
                        local package_count=$(grep "Total packages:" "$host_dir/backup_info.txt" | cut -d: -f2 | xargs)
                        echo "  ‚Ä¢ $hostname (packages: $package_count, $last_backup)"
                    else
                        echo "  ‚Ä¢ $hostname"
                    fi
                fi
            done
        fi
        return 0
    fi

    log_info "Available profiles:"
    echo ""
    
    # Profile-based backups
    if [ -d "$BACKUP_DIR/$PROFILES_DIR" ]; then
        local found_profiles=false
        for profile_dir in "$BACKUP_DIR/$PROFILES_DIR"/*; do
            if [ -d "$profile_dir" ] && [ -f "$profile_dir/Brewfile" ]; then
                local profile=$(basename "$profile_dir")
                found_profiles=true
                
                # Basic profile info
                local pkg_count
                pkg_count=$(grep -c '^[^#]' "$profile_dir/Brewfile" 2>/dev/null || echo "0")
                
                # Check for metadata.json
                if [ -f "$profile_dir/metadata.json" ]; then
                    local last_backup
                    local hostname
                    local brew_count
                    local cask_count
                    local mas_count
                    
                    last_backup=$(get_metadata_field "$profile_dir/metadata.json" "last_backup" "unknown")
                    hostname=$(get_metadata_field "$profile_dir/metadata.json" "hostname" "unknown")
                    brew_count=$(get_metadata_field "$profile_dir/metadata.json" "package_count.brew" "0")
                    cask_count=$(get_metadata_field "$profile_dir/metadata.json" "package_count.cask" "0")
                    mas_count=$(get_metadata_field "$profile_dir/metadata.json" "package_count.mas" "0")
                    
                    echo "Profile: $profile"
                    echo "   Last backup: $last_backup"
                    echo "   From host: $hostname"
                    echo "   Packages: brew($brew_count) cask($cask_count) mas($mas_count)"
                # Fallback to backup_info.txt
                elif [ -f "$profile_dir/backup_info.txt" ]; then
                    local last_backup=$(grep "Last backup:" "$profile_dir/backup_info.txt" | cut -d: -f2- | xargs)
                    local hostname=$(grep "Hostname:" "$profile_dir/backup_info.txt" | cut -d: -f2- | xargs)
                    echo "Profile: $profile"
                    echo "   Last backup: $last_backup"
                    echo "   From host: $hostname"
                    echo "   Packages: $pkg_count"
                else
                    echo "Profile: $profile (packages: $pkg_count)"
                fi
                
                # Show backup files count
                local backup_files
                backup_files=$(find "$profile_dir" -name "Brewfile_*" -type f | wc -l | tr -d ' ')
                if [ "$backup_files" -gt 0 ]; then
                    echo "   Backup files: $backup_files"
                fi
                
                echo ""
            fi
        done
        
        # Clean up old history files (keep only latest N backups per profile)
        if [ "$KEEP_HISTORY" -gt 0 ]; then
            echo "Cleaning up backup history (keeping $KEEP_HISTORY most recent per profile)..."
            
            for profile_path in "$BACKUP_DIR"/profiles/*/; do
                if [ -d "$profile_path" ]; then
                    local profile_name=$(basename "$profile_path")
                    local backup_files
                    
                    # Get all backup files sorted by modification time (newest first)
                    backup_files=$(find "$profile_path" -name "Brewfile_[0-9]*" -type f | sort -r)
                    
                    local count=0
                    local removed_count=0
                    
                    while IFS= read -r backup_file; do
                        if [ -n "$backup_file" ]; then
                            count=$((count + 1))
                            
                            # Keep the first KEEP_HISTORY files, remove the rest
                            if [ $count -gt "$KEEP_HISTORY" ]; then
                                if [ "$DRY_RUN" = true ]; then
                                    echo "[DRY RUN] Would remove: $(basename "$backup_file")"
                                else
                                    rm "$backup_file"
                                    echo "Removed old backup: $(basename "$backup_file")"
                                fi
                                removed_count=$((removed_count + 1))
                            fi
                        fi
                    done <<< "$backup_files"
                    
                    if [ $removed_count -gt 0 ]; then
                        echo "Profile '$profile_name': removed $removed_count old backup(s)"
                    fi
                fi
            done
        fi
        
        if [ "$found_profiles" = false ]; then
            echo "No profiles found. Run 'brew-sync backup' to create your first profile."
        fi
    else
        echo "No profiles found. Run 'brew-sync backup' to create your first profile."
    fi
}

# Function: Backup implementation
do_backup() {
    # Default options
    local PROFILE=""
    local CUSTOM_PATH=""
    local USE_GIT=false
    local AUTO_DETECT=true
    local INTERACTIVE_STORAGE=false
    local DRY_RUN=false

    # Check if first argument is a profile name (not an option)
    if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
        PROFILE="$1"
        shift
    fi

    # Parse backup arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --select-storage)
                INTERACTIVE_STORAGE=true
                AUTO_DETECT=false
                shift
                ;;
            --icloud)
                CUSTOM_PATH="$DEFAULT_BACKUP_DIR"
                AUTO_DETECT=false
                shift
                ;;
            --git)
                USE_GIT=true
                AUTO_DETECT=false
                shift
                ;;
            --dropbox)
                for dropbox_path in "$HOME/Dropbox" "$HOME/Library/CloudStorage/Dropbox-*"; do
                    if [ -d "$dropbox_path" ]; then
                        CUSTOM_PATH="$dropbox_path/brew-backup"
                        break
                    fi
                done
                if [ -z "$CUSTOM_PATH" ]; then
                    log_error "Dropbox folder not found."
                    exit 1
                fi
                AUTO_DETECT=false
                shift
                ;;
            --google-drive)
                for gdrive_path in "$HOME/Google Drive" "$HOME/Library/CloudStorage/GoogleDrive-*"; do
                    if [ -d "$gdrive_path" ]; then
                        CUSTOM_PATH="$gdrive_path/brew-backup"
                        break
                    fi
                done
                if [ -z "$CUSTOM_PATH" ]; then
                    log_error "Google Drive folder not found."
                    exit 1
                fi
                AUTO_DETECT=false
                shift
                ;;
            --path)
                CUSTOM_PATH="$2"
                AUTO_DETECT=false
                shift 2
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -h|--help)
                backup_usage
                exit 0
                ;;
            --help-all)
                backup_usage_full
                exit 0
                ;;
            *)
                log_error "Unknown backup option: $1"
                backup_usage
                exit 1
                ;;
        esac
    done

    # Determine backup location
    if [ "$USE_GIT" = true ]; then
        handle_git_backup
    elif [ -n "$CUSTOM_PATH" ]; then
        BACKUP_DIR="$CUSTOM_PATH"
        BACKUP_METHOD="custom"
    elif [ "$INTERACTIVE_STORAGE" = true ]; then
        detect_backup_location "interactive"
    elif [ "$AUTO_DETECT" = true ]; then
        detect_backup_location
    else
        BACKUP_DIR="$DEFAULT_BACKUP_DIR"
        BACKUP_METHOD="icloud"
    fi

    # Check for migration before proceeding
    if check_migration_needed "$BACKUP_DIR"; then
        migrate_hosts_to_profiles "$BACKUP_DIR" || {
            log_error "Migration failed. Backup aborted."
            exit 1
        }
    fi

    # Set profile (default to 'default' if not specified)
    if [ -z "$PROFILE" ]; then
        # Try to load default profile from config
        if loaded_profile=$(load_default_profile); then
            PROFILE="$loaded_profile"
        else
            PROFILE="$DEFAULT_PROFILE"
        fi
    fi

    # Validate profile name
    if ! validate_profile_name "$PROFILE"; then
        log_error "Invalid profile name: '$PROFILE'"
        log_info "Profile names must be alphanumeric with hyphens/underscores only (max 50 chars)"
        log_info "Reserved names: hosts, merged, common, .migration"
        exit 1
    fi

    # Set directory paths - use profiles/ structure
    PROFILE_DIR=$(get_profile_path "$BACKUP_DIR" "$PROFILE")
    
    log_verbose_plain "Using profile: $PROFILE"

    # Check Homebrew installation
    if ! command -v brew &> /dev/null; then
        log_error "Homebrew is not installed."
        exit 1
    fi

    # Check and create backup directory
    if [ "$BACKUP_METHOD" = "icloud" ] && [ ! -d "$ICLOUD_PATH" ]; then
        log_error "iCloud Drive is not enabled or path not found."
        log_info "iCloud Drive path: $ICLOUD_PATH"
        log_info "Please use alternative backup methods:"
        log_info "  --git                Use Git repository"
        log_info "  --dropbox            Use Dropbox" 
        log_info "  --google-drive       Use Google Drive"
        log_info "  --path ~/backup      Custom path"
        exit 1
    fi

    # Create backup directories
    mkdir -p "$PROFILE_DIR"

    log_verbose "Starting backup for profile '$PROFILE' on host '$HOSTNAME'"

    # Generate Brewfile in temporary directory
    TEMP_DIR=$(mktemp -d)
    cd "$TEMP_DIR"

    # Generate Brewfile
    log_verbose "Generating current package list..."
    if brew bundle dump --force >/dev/null 2>&1; then
        log_verbose "Package list generated successfully"
    else
        log_error "Failed to generate package list"
        rm -rf "$TEMP_DIR"
        exit 1
    fi
    
    # If dry-run, show preview and exit
    if [ "$DRY_RUN" = true ]; then
        log_info "=== DRY RUN mode ==="
        log_verbose_plain "Would backup current packages to profile: $PROFILE"
        log_verbose_plain "Backup location: $BACKUP_DIR/profiles/$PROFILE"
        
        # Count packages
        local brew_count=$(grep -c "^brew " "$TEMP_DIR/$BREWFILE_NAME" 2>/dev/null || echo "0")
        local cask_count=$(grep -c "^cask " "$TEMP_DIR/$BREWFILE_NAME" 2>/dev/null || echo "0")
        local mas_count=$(grep -c "^mas " "$TEMP_DIR/$BREWFILE_NAME" 2>/dev/null || echo "0")
        local total_count=$((brew_count + cask_count + mas_count))
        
        echo "Packages: $brew_count brew, $cask_count cask, $mas_count mas ($total_count total)"
        
        # Check if there are changes
        if [ -f "$PROFILE_DIR/$BREWFILE_NAME" ]; then
            if ! diff "$TEMP_DIR/$BREWFILE_NAME" "$PROFILE_DIR/$BREWFILE_NAME" >/dev/null 2>&1; then
                log_info "Changes detected - backup would proceed"
            else
                echo "No changes detected - backup would be skipped"
            fi
        else
            log_info "No existing backup - new backup would be created"
        fi
        
        echo ""
        echo "To proceed: brew-sync backup $PROFILE"
        
        rm -rf "$TEMP_DIR"
        return 0
    fi

    # Profile-specific backup
    CURRENT_BREWFILE="$TEMP_DIR/$BREWFILE_NAME"
    PROFILE_BREWFILE="$PROFILE_DIR/$BREWFILE_NAME"

    # Compare with existing file
    local CHANGES_DETECTED=false
    if [ -f "$PROFILE_BREWFILE" ]; then
        if cmp -s "$CURRENT_BREWFILE" "$PROFILE_BREWFILE"; then
            log_info "[$HOSTNAME] No changes detected."
            CHANGES_DETECTED=false
        else
            log_info "[$HOSTNAME] Changes detected."
            # Backup existing file with timestamp
            BACKUP_FILE="$PROFILE_DIR/Brewfile_$TIMESTAMP"
            cp "$PROFILE_BREWFILE" "$BACKUP_FILE"
            log_info "[$HOSTNAME] Backed up existing Brewfile: Brewfile_$TIMESTAMP"
            CHANGES_DETECTED=true
        fi
    else
        log_info "[$HOSTNAME] First backup."
        CHANGES_DETECTED=true
    fi

    # Copy new Brewfile to host directory
    cp "$CURRENT_BREWFILE" "$PROFILE_BREWFILE"

    # Create profile-specific backup info file
    cat > "$PROFILE_DIR/backup_info.txt" << EOF
Hostname: $HOSTNAME
Last backup: $(date "+%Y-%m-%d %H:%M:%S")
User: $(whoami)
macOS version: $(sw_vers -productVersion)
Homebrew version: $(brew --version | head -n1)
Profile: ${PROFILE:-"default"}
Total packages: $(grep -E '^(brew|cask|mas)' "$PROFILE_BREWFILE" | wc -l | tr -d ' ')
EOF

    # Package statistics
    BREW_COUNT=$(grep '^brew ' "$PROFILE_BREWFILE" | wc -l | tr -d ' ')
    CASK_COUNT=$(grep '^cask ' "$PROFILE_BREWFILE" | wc -l | tr -d ' ')
    MAS_COUNT=$(grep '^mas ' "$PROFILE_BREWFILE" | wc -l | tr -d ' ')

    # Show summary based on verbosity
    local total_packages=$((BREW_COUNT + CASK_COUNT + MAS_COUNT))
    log_success "Backup completed ($total_packages packages)"
    log_verbose "Location: $PROFILE_BREWFILE"
    log_verbose "Packages: $BREW_COUNT brew, $CASK_COUNT cask, $MAS_COUNT MAS apps"
    
    # Create metadata.json for the profile
    cat > "$PROFILE_DIR/metadata.json" <<EOF
{
    "profile": "$PROFILE",
    "hostname": "$HOSTNAME",
    "last_backup": "$(date -Iseconds)",
    "user": "$(whoami)",
    "macos_version": "$(sw_vers -productVersion)",
    "homebrew_version": "$(brew --version | head -n1)",
    "package_count": {
        "brew": $BREW_COUNT,
        "cask": $CASK_COUNT,
        "mas": $MAS_COUNT
    }
}
EOF

    # Save the successful backup storage choice for future use
    save_last_storage "$BACKUP_METHOD" "$BACKUP_DIR"

    # Clean up temporary directory
    rm -rf "$TEMP_DIR"

    # Simple cleanup for profile directory
    if [ "$CHANGES_DETECTED" = true ]; then
        log_info "Running automatic backup cleanup..."
        
        # Remove old backup files in profile directory (keep last 5)
        if [ -d "$PROFILE_DIR" ]; then
            find "$PROFILE_DIR" -name "Brewfile_*" -type f | sort -r | tail -n +6 | xargs rm -f 2>/dev/null || true
        fi
        
        log_info "Automatic cleanup completed"
    fi

    log_success "All operations completed!"

    # Git repository commit and push suggestion
    if [ "$BACKUP_METHOD" = "git" ] && [ "$CHANGES_DETECTED" = true ]; then
        echo ""
        log_info "üîÑ Git backup follow-up actions:"
        log_info "  Commit changes: git add . && git commit -m \"Update profile '$PROFILE' from $HOSTNAME\""
        log_info "  Push to remote: git push"
        echo ""
        echo -n "Would you like to commit and push to Git now? (y/N): "
        read -r git_response
        if [[ "$git_response" =~ ^[Yy]$ ]]; then
            cd "$BACKUP_DIR"
            git add .
            if git commit -m "Update profile '$PROFILE' from $HOSTNAME - $(date "+%Y-%m-%d %H:%M:%S")"; then
                log_success "Git commit completed"
                if git push 2>/dev/null; then
                    log_success "Git push completed"
                else
                    log_warning "Git push failed. Please push manually: git push"
                fi
            else
                log_info "No changes to commit."
            fi
        fi
    fi

    # Available restore options guide
    echo ""
    log_info "Restore options:"
    case "$BACKUP_METHOD" in
        "git")
            if [ "$PROFILE" = "default" ]; then
                log_info "  On other Mac: git clone <repository-url> && cd <repo> && brew-sync restore"
            else
                log_info "  On other Mac: git clone <repository-url> && cd <repo> && brew-sync restore $PROFILE"
            fi
            ;;
        "icloud"|"dropbox"|"google-drive")
            log_info "  On other Mac with same cloud service synced:"
            ;;
        "local")
            log_info "  Available only on current Mac:"
            ;;
        "custom")
            log_info "  On other Mac with access to same path:"
            ;;
    esac

    if [ "$BACKUP_METHOD" != "git" ]; then
        if [ "$PROFILE" = "default" ]; then
            log_info "  Restore: brew-sync restore"
        else
            log_info "  Restore: brew-sync restore $PROFILE"
        fi
        
        # Additional guidance by backup method
        case "$BACKUP_METHOD" in
            "local")
                log_warning "Local backup is only available on current Mac."
                log_info "For sharing with other Macs, consider using cloud services or Git."
                ;;
        esac
    fi
}

# Function: Restore implementation
do_restore() {
    # Default options
    local DRY_RUN=false
    local FORCE=false
    local SKIP_MAS=false
    local PROFILE=""
    local CUSTOM_PATH=""
    local USE_GIT=false
    local AUTO_DETECT=true
    local INTERACTIVE_STORAGE=false

    # Check if first argument is a profile name (not an option)
    if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
        PROFILE="$1"
        shift
    fi

    # Parse restore arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -f|--force)
                FORCE=true
                shift
                ;;
            --skip-mas)
                SKIP_MAS=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -l|--list)
                # Auto-detect backup location for listing
                detect_backup_location 2>/dev/null || BACKUP_DIR="$DEFAULT_BACKUP_DIR"
                list_backups
                exit 0
                ;;
            --icloud)
                CUSTOM_PATH="$DEFAULT_BACKUP_DIR"
                AUTO_DETECT=false
                shift
                ;;
            --git)
                USE_GIT=true
                AUTO_DETECT=false
                shift
                ;;
            --dropbox)
                for dropbox_path in "$HOME/Dropbox" "$HOME/Library/CloudStorage/Dropbox-*"; do
                    if [ -d "$dropbox_path" ]; then
                        CUSTOM_PATH="$dropbox_path/brew-backup"
                        break
                    fi
                done
                if [ -z "$CUSTOM_PATH" ]; then
                    log_error "Dropbox folder not found."
                    exit 1
                fi
                AUTO_DETECT=false
                shift
                ;;
            --google-drive)
                for gdrive_path in "$HOME/Google Drive" "$HOME/Library/CloudStorage/GoogleDrive-*"; do
                    if [ -d "$gdrive_path" ]; then
                        CUSTOM_PATH="$gdrive_path/brew-backup"
                        break
                    fi
                done
                if [ -z "$CUSTOM_PATH" ]; then
                    log_error "Google Drive folder not found."
                    exit 1
                fi
                AUTO_DETECT=false
                shift
                ;;
            --path)
                CUSTOM_PATH="$2"
                AUTO_DETECT=false
                shift 2
                ;;
            --select-storage)
                INTERACTIVE_STORAGE=true
                AUTO_DETECT=false
                shift
                ;;
            -h|--help)
                restore_usage
                exit 0
                ;;
            --help-all)
                restore_usage_full
                exit 0
                ;;
            *)
                log_error "Unknown restore option: $1"
                restore_usage
                exit 1
                ;;
        esac
    done

    # Determine backup location
    if [ "$USE_GIT" = true ]; then
        handle_git_backup
    elif [ -n "$CUSTOM_PATH" ]; then
        BACKUP_DIR="$CUSTOM_PATH"
        BACKUP_METHOD="custom"
    elif [ "$INTERACTIVE_STORAGE" = true ]; then
        detect_backup_location "interactive"
    elif [ "$AUTO_DETECT" = true ]; then
        detect_backup_location
    else
        BACKUP_DIR="$DEFAULT_BACKUP_DIR"
        BACKUP_METHOD="icloud"
    fi

    # Check for migration before proceeding
    if check_migration_needed "$BACKUP_DIR"; then
        migrate_hosts_to_profiles "$BACKUP_DIR" || {
            log_error "Migration failed. Restore aborted."
            exit 1
        }
    fi

    # Set profile (default to 'default' if not specified)
    if [ -z "$PROFILE" ]; then
        # Try to load default profile from config
        if loaded_profile=$(load_default_profile); then
            PROFILE="$loaded_profile"
        else
            PROFILE="$DEFAULT_PROFILE"
        fi
    fi

    # Validate profile name
    if ! validate_profile_name "$PROFILE"; then
        log_error "Invalid profile name: '$PROFILE'"
        log_info "Profile names must be alphanumeric with hyphens/underscores only (max 50 chars)"
        log_info "Reserved names: hosts, merged, common, .migration"
        exit 1
    fi

    # Get profile directory and Brewfile path
    local PROFILE_DIR
    PROFILE_DIR=$(get_profile_path "$BACKUP_DIR" "$PROFILE")
    local BACKUP_BREWFILE="$PROFILE_DIR/Brewfile"
    
    # Check if profile exists
    if [ ! -f "$BACKUP_BREWFILE" ]; then
        log_error "Profile '$PROFILE' not found or no Brewfile exists."
        log_info "Available profiles:"
        if get_available_profiles "$BACKUP_DIR" >/dev/null 2>&1; then
            get_available_profiles "$BACKUP_DIR" | while read -r profile_name; do
                echo "  - $profile_name"
            done
        else
            echo "  No profiles found."
        fi
        exit 1
    fi

    local SOURCE_DESC="Profile '$PROFILE'"


    # Check Homebrew installation
    if ! command -v brew &> /dev/null; then
        log_warning "Homebrew is not installed. Installing..."
        if [ "$DRY_RUN" = false ]; then
            /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
            log_success "Homebrew installation completed"
        else
            log_info "[DRY-RUN] Installing Homebrew"
        fi
    fi

    # Analyze Brewfile contents
    BREW_COUNT=$(grep '^brew ' "$BACKUP_BREWFILE" | wc -l | tr -d ' ')
    CASK_COUNT=$(grep '^cask ' "$BACKUP_BREWFILE" | wc -l | tr -d ' ')
    MAS_COUNT=$(grep '^mas ' "$BACKUP_BREWFILE" | wc -l | tr -d ' ')

    if [ "$DRY_RUN" = true ]; then
        log_info "=== DRY RUN mode - No actual installation will be performed ==="
        echo
        log_info "  Actual installation: brew-sync restore --profile $PROFILE"
    fi

    log_restore "Restore source: $SOURCE_DESC"
    log_info "Brewfile path: $BACKUP_BREWFILE"

    # Output profile information
    BACKUP_INFO_FILE="$PROFILE_DIR/backup_info.txt"
    METADATA_FILE="$PROFILE_DIR/metadata.json"

    if [ -f "$METADATA_FILE" ]; then
        log_info "Profile information:"
        local last_backup
        local hostname
        local brew_count
        local cask_count
        local mas_count
        
        last_backup=$(get_metadata_field "$METADATA_FILE" "last_backup" "unknown")
        hostname=$(get_metadata_field "$METADATA_FILE" "hostname" "unknown")
        brew_count=$(get_metadata_field "$METADATA_FILE" "package_count.brew" "0")
        cask_count=$(get_metadata_field "$METADATA_FILE" "package_count.cask" "0")
        mas_count=$(get_metadata_field "$METADATA_FILE" "package_count.mas" "0")
        
        echo "  Last backup: $last_backup"
        echo "  From host: $hostname"
        echo "  Packages: brew($brew_count) cask($cask_count) mas($mas_count)"
        echo
    elif [ -f "$BACKUP_INFO_FILE" ]; then
        log_info "Backup information:"
        cat "$BACKUP_INFO_FILE" | sed 's/^/  /'
        echo
    fi

    log_info "Package information to restore:"
    log_info "  - Homebrew packages: $BREW_COUNT"
    log_info "  - Cask apps: $CASK_COUNT"
    log_info "  - Mac App Store apps: $MAS_COUNT"
    echo

    # Create temporary directory for Brewfile
    TEMP_BREWFILE_DIR=$(mktemp -d)
    TEMP_BREWFILE="$TEMP_BREWFILE_DIR/Brewfile"
    
    if [ "$DRY_RUN" = false ]; then
        cp "$BACKUP_BREWFILE" "$TEMP_BREWFILE"
        log_success "Copied Brewfile to temporary directory"
    else
        log_info "[DRY-RUN] Copying Brewfile to temporary directory"
    fi

    # Check Mac App Store CLI tool (mas if needed)
    if [ "$MAS_COUNT" -gt 0 ] && [ "$SKIP_MAS" = false ]; then
        if ! command -v mas &> /dev/null; then
            log_info "Mac App Store CLI tool (mas) is required. Installing..."
            if [ "$DRY_RUN" = false ]; then
                brew install mas
            else
                log_info "[DRY-RUN] Installing mas"
            fi
        fi
    fi

    # Configure bundle command
    BUNDLE_ARGS=""
    if [ "$VERBOSE" = true ]; then
        BUNDLE_ARGS="$BUNDLE_ARGS --verbose"
    fi

    if [ "$SKIP_MAS" = true ]; then
        BUNDLE_ARGS="$BUNDLE_ARGS --no-mas"
        log_verbose "Skipping Mac App Store app installation"
    fi

    # Start package installation  
    log_verbose "Starting package installation from $TEMP_BREWFILE"

    if [ "$DRY_RUN" = true ]; then
        log_verbose "[DRY-RUN] Checking package requirements"
        if brew bundle check --file="$TEMP_BREWFILE" --no-upgrade 2>/dev/null; then
            log_info "[DRY-RUN] All packages are already installed"
        else
            log_info "[DRY-RUN] Packages that need installation:"
            brew bundle check --file="$TEMP_BREWFILE" --no-upgrade 2>&1 | grep -E "^(brew|cask|mas)" | head -10
            TOTAL_MISSING=$(brew bundle check --file="$TEMP_BREWFILE" --no-upgrade 2>&1 | grep -E "^(brew|cask|mas)" | wc -l | tr -d ' ')
            if [ "$TOTAL_MISSING" -gt 10 ]; then
                log_info "[DRY-RUN] ... and $((TOTAL_MISSING - 10)) more"
            fi
            log_info "[DRY-RUN] Following command will be executed:"
            log_info "[DRY-RUN] brew bundle --file=\"$TEMP_BREWFILE\" $BUNDLE_ARGS"
        fi
    else
        # Perform actual installation
        log_verbose "Executing: brew bundle --file=\"$TEMP_BREWFILE\" $BUNDLE_ARGS"
        
        if brew bundle --file="$TEMP_BREWFILE" $BUNDLE_ARGS; then
            log_success "Restore completed successfully!"
        else
            log_warning "Some package installations may have failed."
            log_info "Check the output above for details."
            log_info "Retry failed packages: brew bundle --file=\"$TEMP_BREWFILE\" --verbose"
        fi
    fi

    # Post-installation cleanup
    if [ "$DRY_RUN" = false ]; then
        log_info "Performing post-installation cleanup..."
        
        # Homebrew cleanup
        if [ "$VERBOSE" = true ]; then
            brew cleanup --prune=all
        else
            brew cleanup --prune=all &>/dev/null || true
        fi
        
        # Dependency check
        if ! brew doctor &>/dev/null; then
            log_warning "brew doctor warnings detected."
            log_info "To check: brew doctor"
        fi
        
        # Final statistics
        INSTALLED_BREW=$(brew list --formula | wc -l | tr -d ' ')
        INSTALLED_CASK=$(brew list --cask | wc -l | tr -d ' ')
        
        log_success "All operations completed!"
        log_info "Installed environment:"
        log_info "  - Installed packages: Homebrew($INSTALLED_BREW) Cask($INSTALLED_CASK)"
        log_info "  - Check sync: brew bundle check --file=\"$TEMP_BREWFILE\""
        log_info "  - Full list: brew list"
        
    else
        log_info "[DRY-RUN] For actual installation, run again without -d option"
        echo ""
        log_info "Recommended command:"
        log_info "  Actual installation: brew-sync restore --profile $PROFILE"
    fi
    
    # Cleanup temporary directory
    if [ -n "$TEMP_BREWFILE_DIR" ] && [ -d "$TEMP_BREWFILE_DIR" ]; then
        rm -rf "$TEMP_BREWFILE_DIR"
        log_info "Cleaned up temporary files"
    fi
    
}

# Function: Show status (profiles overview or specific profile details)
do_status() {
    local PROFILE=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                echo "Usage: brew-sync status [profile]"
                echo ""
                echo "Show backup status:"
                echo "  status              Show all profiles summary"
                echo "  status <profile>    Show specific profile details"
                echo ""
                echo "Examples:"
                echo "  brew-sync status           # Show all profiles"
                echo "  brew-sync status work      # Show work profile details"
                exit 0
                ;;
            *)
                if [ -z "$PROFILE" ]; then
                    PROFILE="$1"
                else
                    log_error "Unknown status option: $1"
                    exit 1
                fi
                shift
                ;;
        esac
    done
    
    # Determine backup location
    detect_backup_location 2>/dev/null || BACKUP_DIR="$DEFAULT_BACKUP_DIR"
    
    # Check for migration before proceeding
    if check_migration_needed "$BACKUP_DIR"; then
        migrate_hosts_to_profiles "$BACKUP_DIR" || {
            log_error "Migration failed. Status command aborted."
            exit 1
        }
    fi
    
    local profiles_dir="$BACKUP_DIR/profiles"
    
    if [ ! -d "$profiles_dir" ]; then
        log_error "No profiles found at $profiles_dir"
        exit 1
    fi
    
    # Show specific profile details or all profiles summary
    if [ -n "$PROFILE" ]; then
        # Show specific profile details
        local profile_dir="$profiles_dir/$PROFILE"
        if [ ! -d "$profile_dir" ]; then
            log_error "Profile '$PROFILE' not found"
            exit 1
        fi
        
        # Show storage location (concise)
        local storage_info
        if [[ "$BACKUP_DIR" == *"CloudDocs"* ]] || [[ "$BACKUP_DIR" == *"iCloud"* ]]; then
            storage_info="icloud"
        elif [[ "$BACKUP_DIR" == *"Dropbox"* ]]; then
            storage_info="dropbox"
        elif [[ "$BACKUP_DIR" == *"Google Drive"* ]] || [[ "$BACKUP_DIR" == *"GoogleDrive"* ]]; then
            storage_info="google-drive"
        elif [[ "$BACKUP_DIR" == "$HOME/.brew-sync" ]]; then
            storage_info="local"
        else
            storage_info="custom"
        fi
        
        log_status "Storage: $storage_info ($BACKUP_DIR)"
        format_profile_detail "$PROFILE" "$profile_dir"
    else
        # Show all profiles summary
        local storage_info
        if [[ "$BACKUP_DIR" == *"CloudDocs"* ]] || [[ "$BACKUP_DIR" == *"iCloud"* ]]; then
            storage_info="icloud"
        elif [[ "$BACKUP_DIR" == *"Dropbox"* ]]; then
            storage_info="dropbox"
        elif [[ "$BACKUP_DIR" == *"Google Drive"* ]] || [[ "$BACKUP_DIR" == *"GoogleDrive"* ]]; then
            storage_info="google-drive"
        elif [[ "$BACKUP_DIR" == "$HOME/.brew-sync" ]]; then
            storage_info="local"
        else
            storage_info="custom"
        fi
        
        log_status "Profiles ($storage_info):"
        
        # List all profiles
        local found_any=false
        for profile_path in "$profiles_dir"/*; do
            if [ -d "$profile_path" ]; then
                local profile_name
                profile_name=$(basename "$profile_path")
                format_profile_summary "$profile_name" "$profile_path"
                found_any=true
            fi
        done
        
        if [ "$found_any" = false ]; then
            echo "No profiles found"
        fi
    fi
}

# Function: Show backup history for a profile
do_history() {
    local profile="$1"
    
    if [ "$profile" = "--help" ] || [ "$profile" = "-h" ]; then
        history_usage
        return 0
    fi
    
    local backup_dir
    if [ -f "$LAST_STORAGE_FILE" ]; then
        backup_dir=$(grep "^path=" "$LAST_STORAGE_FILE" | cut -d'=' -f2 | tr -d '"')
    else
        log_error "No backup location configured. Run 'brew-sync backup' first."
        return 1
    fi
    
    if [ -z "$profile" ]; then
        # Try to load default profile if none specified
        if ! profile=$(load_default_profile); then
            log_error "Profile name required"
            history_usage
            return 1
        fi
        log_verbose_plain "Using default profile: $profile"
    fi
    
    # Get backup history
    local backup_files
    backup_files=$(get_backup_history "$profile" "$backup_dir")
    
    if [ $? -ne 0 ] || [ -z "$backup_files" ]; then
        log_error "No history found for profile '$profile'"
        return 1
    fi
    
    echo "Backup history for '$profile':"
    
    local index=1
    while IFS= read -r backup_file; do
        if [ -n "$backup_file" ]; then
            local info
            info=$(parse_backup_info "$backup_file")
            if [ -n "$info" ]; then
                local datetime=$(echo "$info" | cut -d'|' -f1)
                local count=$(echo "$info" | cut -d'|' -f2)
                local relative_time
                relative_time=$(format_relative_time "$datetime")
                
                echo "[$index] $relative_time ($count packages)"
                index=$((index + 1))
            fi
        fi
    done <<< "$backup_files"
    
    if [ $index -eq 1 ]; then
        echo "No backup history found"
    fi
}

# Function: Rollback to previous backup
do_rollback() {
    local profile=""
    local index=""
    local dry_run=""
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case $1 in
            --help|-h)
                rollback_usage
                return 0
                ;;
            --dry-run|-d)
                dry_run="true"
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                rollback_usage
                return 1
                ;;
            *)
                if [ -z "$profile" ]; then
                    profile="$1"
                elif [ -z "$index" ]; then
                    index="$1"
                fi
                shift
                ;;
        esac
    done
    
    if [ -z "$profile" ]; then
        # Try to load default profile if none specified
        if ! profile=$(load_default_profile); then
            log_error "Profile name required"
            rollback_usage
            return 1
        fi
        log_verbose_plain "Using default profile: $profile"
    fi
    
    # Get backup directory
    local backup_dir
    if [ -f "$LAST_STORAGE_FILE" ]; then
        backup_dir=$(grep "^path=" "$LAST_STORAGE_FILE" | cut -d'=' -f2 | tr -d '"')
    else
        log_error "No backup location configured. Run 'brew-sync backup' first."
        return 1
    fi
    
    # Get backup history
    local backup_files
    backup_files=$(get_backup_history "$profile" "$backup_dir")
    
    if [ $? -ne 0 ] || [ -z "$backup_files" ]; then
        log_error "No history found for profile '$profile'"
        return 1
    fi
    
    # Convert backup files to array for indexing
    local -a backup_array
    while IFS= read -r backup_file; do
        if [ -n "$backup_file" ]; then
            backup_array+=("$backup_file")
        fi
    done <<< "$backup_files"
    
    # If no index specified, show interactive selection
    if [ -z "$index" ]; then
        echo "Available backups for '$profile':"
        local i=1
        for backup_file in "${backup_array[@]}"; do
            local info
            info=$(parse_backup_info "$backup_file")
            if [ -n "$info" ]; then
                local datetime=$(echo "$info" | cut -d'|' -f1)
                local count=$(echo "$info" | cut -d'|' -f2)
                local relative_time
                relative_time=$(format_relative_time "$datetime")
                
                echo "[$i] $relative_time ($count packages)"
                i=$((i + 1))
            fi
        done
        echo ""
        read -p "Select backup to restore [1-$((i-1))]: " index
    fi
    
    # Validate index
    if ! [[ "$index" =~ ^[0-9]+$ ]] || [ "$index" -lt 1 ] || [ "$index" -gt ${#backup_array[@]} ]; then
        log_error "Invalid selection: $index"
        return 1
    fi
    
    # Get selected backup file
    local selected_backup="${backup_array[$((index-1))]}"
    local info
    info=$(parse_backup_info "$selected_backup")
    local datetime=$(echo "$info" | cut -d'|' -f1)
    local count=$(echo "$info" | cut -d'|' -f2)
    local relative_time
    relative_time=$(format_relative_time "$datetime")
    
    if [ "$dry_run" = "true" ]; then
        echo "=== DRY RUN mode ==="
        echo "Would rollback profile '$profile' to:"
        echo "  Backup: $relative_time ($count packages)"
        echo "  File: $(basename "$selected_backup")"
        echo ""
        echo "To proceed: brew-sync rollback $profile $index"
        return 0
    fi
    
    # Confirm rollback
    echo "Rollback profile '$profile' to $relative_time backup?"
    echo "This will replace last version of '$profile' profile. Continue? [y/N]"
    read -r confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "Rollback cancelled"
        return 0
    fi
    
    # Perform rollback
    local profile_dir="$backup_dir/profiles/$profile"
    local current_brewfile="$profile_dir/Brewfile"
    
    # Backup current state first
    if [ -f "$current_brewfile" ]; then
        local backup_timestamp
        backup_timestamp=$(date +%Y%m%d_%H%M%S)
        local current_backup="$profile_dir/Brewfile_rollback_backup_$backup_timestamp"
        cp "$current_brewfile" "$current_backup"
        log_info "Current state backed up as: $(basename "$current_backup")"
    fi
    
    # Copy selected backup to current Brewfile
    if [[ "$selected_backup" == *.gz ]]; then
        zcat "$selected_backup" > "$current_brewfile"
    else
        cp "$selected_backup" "$current_brewfile"
    fi
    
    log_success "Rollback completed"
    echo "Profile '$profile' restored to $relative_time backup"
}

# Function: Print rollback usage
rollback_usage() {
    echo "Usage: brew-sync rollback [profile] [index] [options]"
    echo ""
    echo "Rollback profile to previous backup"
    echo ""
    echo "Arguments:"
    echo "  profile              Profile name (optional, uses default if not specified)"
    echo "  index                Backup index (optional, interactive if not specified)"
    echo ""
    echo "Options:"
    echo "  -d, --dry-run        Preview rollback without making changes"
    echo "  -h, --help              Show this help"
    echo ""
    echo "Examples:"
    echo "  brew-sync rollback              # Interactive selection (uses default profile)"
    echo "  brew-sync rollback work         # Interactive selection for work profile"
    echo "  brew-sync rollback work 2       # Rollback to 2nd backup"
    echo "  brew-sync rollback work 1 --dry-run  # Preview rollback"
}

# Function: Print history usage
history_usage() {
    echo "Usage: brew-sync history [profile]"
    echo ""
    echo "Show backup history for profile"
    echo ""
    echo "Arguments:"
    echo "  profile              Profile name (optional, uses default if not specified)"
    echo ""
    echo "Examples:"
    echo "  brew-sync history           # Show history for default profile"
    echo "  brew-sync history work      # Show work profile history"
    echo "  brew-sync history default   # Show default profile history"
}

# Function: Print update usage
update_usage() {
    echo "Usage: brew-sync update [options]"
    echo ""
    echo "Options:"
    echo "  --check              Check for updates without installing"
    echo "  -h, --help              Show this help message"
    echo ""
    echo "Examples:"
    echo "  brew-sync update                # Update to latest version"
    echo "  brew-sync update --check        # Check if update is available"
    echo ""
    echo "The update command compares the current version with the latest"
    echo "version from GitHub and updates if a newer version is available."
}

# Function: Uninstall brew-sync
uninstall_brew_sync() {
    log_info "Uninstalling brew-sync..."
    
    # Determine installation directory
    local install_dir="/usr/local/bin"
    if [[ $(uname -m) == "arm64" ]]; then
        install_dir="/opt/homebrew/bin"
    fi
    
    local script_path="$install_dir/brew-sync"
    
    # Check if the script exists
    if [ ! -f "$script_path" ]; then
        log_error "brew-sync is not installed at $script_path"
        return 1
    fi
    
    # Ask for confirmation
    echo ""
    log_warning "This will remove brew-sync from your system."
    echo -n "Are you sure you want to continue? (y/N): "
    read -r response
    
    case "$response" in
        [yY][eE][sS]|[yY])
            # Remove the script
            if [ -w "$install_dir" ]; then
                rm -f "$script_path"
                log_success "brew-sync has been uninstalled successfully"
            else
                sudo rm -f "$script_path"
                log_success "brew-sync has been uninstalled successfully (with sudo)"
            fi
            
            log_info "Note: Your backup files remain untouched."
            log_info "If you want to remove backup files, manually delete them from:"
            log_info "  - iCloud Drive: ~/Library/Mobile Documents/com~apple~CloudDocs/brew-backup"
            log_info "  - Other locations you may have configured"
            log_info ""
            log_info "Configuration files in ~/.config/brew-sync/ will also remain."
            ;;
        *)
            log_info "Uninstall cancelled."
            return 0
            ;;
    esac
}

# Function: Check for updates
check_for_updates() {
    local check_only="$1"
    
    # Handle help option
    if [ "$check_only" = "--help" ] || [ "$check_only" = "-h" ]; then
        update_usage
        exit 0
    fi
    
    log_info "Checking for updates..."
    
    # Get current script hash
    local current_hash
    current_hash=$(md5 "$SCRIPT_PATH" 2>/dev/null | cut -d' ' -f4)
    if [ -z "$current_hash" ]; then
        log_error "Failed to calculate current script hash."
        return 1
    fi
    
    log_info "Current script hash: ${current_hash:0:8}..."
    
    # Download latest version to temporary file
    local temp_script
    temp_script=$(mktemp)
    if ! curl -s "https://raw.githubusercontent.com/$GITHUB_REPO/main/brew-sync" -o "$temp_script"; then
        log_error "Failed to download latest version. Please check your internet connection."
        rm -f "$temp_script"
        return 1
    fi
    
    # Get latest script hash
    local latest_hash
    latest_hash=$(md5 "$temp_script" 2>/dev/null | cut -d' ' -f4)
    if [ -z "$latest_hash" ]; then
        log_error "Failed to calculate latest script hash."
        rm -f "$temp_script"
        return 1
    fi
    
    log_info "Latest script hash: ${latest_hash:0:8}..."
    
    # Compare hashes
    if [ "$current_hash" = "$latest_hash" ]; then
        log_success "You are already using the latest version!"
        rm -f "$temp_script"
        return 0
    fi
    
    if [ "$check_only" = "--check" ]; then
        log_info "A new version is available."
        log_info "Run 'brew-sync update' to update."
        rm -f "$temp_script"
        return 0
    fi
    
    # Perform update
    log_info "New version available!"
    echo -n "Do you want to update? (y/N): "
    read -r response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
        log_info "Update cancelled."
        rm -f "$temp_script"
        return 0
    fi
    
    # Find current script location
    local script_path
    script_path=$(which brew-sync 2>/dev/null || readlink -f "$SCRIPT_PATH" 2>/dev/null || echo "$SCRIPT_PATH")
    if [ ! -f "$script_path" ]; then
        log_error "Could not determine script location. Please reinstall manually."
        rm -f "$temp_script"
        return 1
    fi
    
    log_info "Updating brew-sync at: $script_path"
    
    # Backup current version
    local backup_path="${script_path}.backup.$(date +%Y%m%d_%H%M%S)"
    if ! cp "$script_path" "$backup_path"; then
        log_error "Failed to backup current version."
        rm -f "$temp_script"
        return 1
    fi
    
    # Replace script (may require sudo)
    if cp "$temp_script" "$script_path" 2>/dev/null; then
        log_success "Update completed successfully!"
    elif sudo cp "$temp_script" "$script_path" 2>/dev/null; then
        log_success "Update completed successfully! (required sudo)"
    else
        log_error "Failed to update script. Restoring backup..."
        cp "$backup_path" "$script_path" 2>/dev/null || sudo cp "$backup_path" "$script_path"
        rm -f "$temp_script" "$backup_path"
        return 1
    fi
    
    # Set executable permission and cleanup
    chmod +x "$script_path" 2>/dev/null || sudo chmod +x "$script_path"
    rm -f "$temp_script" "$backup_path"
    
    # Verify update by checking hash
    local new_hash
    new_hash=$(md5 "$script_path" 2>/dev/null | cut -d' ' -f4)
    
    if [ "$new_hash" = "$latest_hash" ]; then
        log_success "Updated successfully!"
        log_info "Previous: ${current_hash:0:8}... ‚Üí Current: ${new_hash:0:8}..."
        
        # Clean exit to prevent executing old code that may cause syntax errors
        log_info "Update complete. Please run the command again if needed."
        exit 0
    else
        log_error "Update verification failed. Hash mismatch."
        log_error "Expected: ${latest_hash:0:8}..., Got: ${new_hash:0:8}..."
        return 1
    fi
}

# Function: Show version
show_version() {
    local script_hash
    script_hash=$(md5 "$SCRIPT_PATH" 2>/dev/null | cut -d' ' -f4)
    local mod_date
    mod_date=$(stat -f %Sm -t "%Y-%m-%d %H:%M" "$SCRIPT_PATH" 2>/dev/null || echo "unknown")
    
    echo "brew-sync"
    echo "Script hash: ${script_hash:0:8}..."
    echo "Modified: $mod_date"
}

# Print usage if no arguments
if [ $# -eq 0 ]; then
    usage
    exit 0
fi

# Determine action based on first argument
case "$1" in
    backup)
        shift
        do_backup "$@"
        ;;
    restore)
        shift
        do_restore "$@"
        ;;
    status)
        shift
        do_status "$@"
        ;;
    history)
        shift
        do_history "$@"
        ;;
    rollback)
        shift
        do_rollback "$@"
        ;;
    edit)
        shift
        edit_profile "$@"
        ;;
    set)
        shift
        set_profile "$@"
        ;;
    remove)
        shift
        remove_profile "$@"
        ;;
    profile)
        shift
        manage_profiles "$@"
        ;;
    cleanup)
        shift
        do_cleanup "$@"
        ;;
    update)
        shift
        check_for_updates "$@"
        ;;
    uninstall)
        shift
        uninstall_brew_sync "$@"
        ;;
    version|--version|-v)
        show_version
        exit 0
        ;;
    help|--help|-h)
        usage
        exit 0
        ;;
    *)
        log_error "Unknown command: $1"
        echo ""
        usage
        exit 1
        ;;
esac